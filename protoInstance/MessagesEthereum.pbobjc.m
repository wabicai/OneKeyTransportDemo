// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: messages-ethereum.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "MessagesEthereum.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(EthereumAddress);
GPBObjCClassDeclaration(EthereumDefinitions);
GPBObjCClassDeclaration(EthereumGetAddress);
GPBObjCClassDeclaration(EthereumGetPublicKey);
GPBObjCClassDeclaration(EthereumMessageSignature);
GPBObjCClassDeclaration(EthereumPublicKey);
GPBObjCClassDeclaration(EthereumSignMessage);
GPBObjCClassDeclaration(EthereumSignTx);
GPBObjCClassDeclaration(EthereumSignTxEIP1559);
GPBObjCClassDeclaration(EthereumSignTxEIP1559_EthereumAccessList);
GPBObjCClassDeclaration(EthereumSignTypedHash);
GPBObjCClassDeclaration(EthereumTxAck);
GPBObjCClassDeclaration(EthereumTxRequest);
GPBObjCClassDeclaration(EthereumTypedDataSignature);
GPBObjCClassDeclaration(EthereumVerifyMessage);
GPBObjCClassDeclaration(HDNodeType);

#pragma mark - MessagesEthereumRoot

@implementation MessagesEthereumRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription MessagesEthereumRoot_FileDescription = {
  .package = "hw.trezor.messages.ethereum",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto2
};

#pragma mark - EthereumGetPublicKey

@implementation EthereumGetPublicKey

@dynamic addressNArray, addressNArray_Count;
@dynamic hasShowDisplay, showDisplay;

typedef struct EthereumGetPublicKey__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
} EthereumGetPublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetPublicKey_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumGetPublicKey__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "showDisplay",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetPublicKey_FieldNumber_ShowDisplay,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumGetPublicKey)
                                   messageName:@"EthereumGetPublicKey"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumGetPublicKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumPublicKey

@implementation EthereumPublicKey

@dynamic hasNode, node;
@dynamic hasXpub, xpub;

typedef struct EthereumPublicKey__storage_ {
  uint32_t _has_storage_[1];
  HDNodeType *node;
  NSString *xpub;
} EthereumPublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.clazz = GPBObjCClass(HDNodeType),
        .number = EthereumPublicKey_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumPublicKey__storage_, node),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "xpub",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumPublicKey_FieldNumber_Xpub,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumPublicKey__storage_, xpub),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumPublicKey)
                                   messageName:@"EthereumPublicKey"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumPublicKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumGetAddress

@implementation EthereumGetAddress

@dynamic addressNArray, addressNArray_Count;
@dynamic hasShowDisplay, showDisplay;
@dynamic hasEncodedNetwork, encodedNetwork;

typedef struct EthereumGetAddress__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  NSData *encodedNetwork;
} EthereumGetAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetAddress_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumGetAddress__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "showDisplay",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetAddress_FieldNumber_ShowDisplay,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "encodedNetwork",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetAddress_FieldNumber_EncodedNetwork,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumGetAddress__storage_, encodedNetwork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumGetAddress)
                                   messageName:@"EthereumGetAddress"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumGetAddress__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumAddress

@implementation EthereumAddress

@dynamic hasOldAddress, oldAddress;
@dynamic hasAddress, address;

typedef struct EthereumAddress__storage_ {
  uint32_t _has_storage_[1];
  NSData *oldAddress;
  NSString *address;
} EthereumAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oldAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumAddress_FieldNumber_OldAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumAddress__storage_, oldAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumAddress_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumAddress__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumAddress)
                                   messageName:@"EthereumAddress"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumAddress__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\203\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTx

@implementation EthereumSignTx

@dynamic addressNArray, addressNArray_Count;
@dynamic hasNonce, nonce;
@dynamic hasGasPrice, gasPrice;
@dynamic hasGasLimit, gasLimit;
@dynamic hasTo, to;
@dynamic hasValue, value;
@dynamic hasDataInitialChunk, dataInitialChunk;
@dynamic hasDataLength, dataLength;
@dynamic hasChainId, chainId;
@dynamic hasTxType, txType;
@dynamic hasDefinitions, definitions;

typedef struct EthereumSignTx__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  uint32_t txType;
  GPBUInt32Array *addressNArray;
  NSData *nonce;
  NSData *gasPrice;
  NSData *gasLimit;
  NSData *value;
  NSData *dataInitialChunk;
  NSString *to;
  EthereumDefinitions *definitions;
  uint64_t chainId;
} EthereumSignTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, nonce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "gasPrice",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_GasPrice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, gasPrice),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "gasLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_GasLimit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, gasLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataInitialChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_DataInitialChunk,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, dataInitialChunk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_DataLength,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, dataLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_ChainId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, chainId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txType",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_TxType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, txType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "to",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTx_FieldNumber_To,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, to),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "definitions",
        .dataTypeSpecific.clazz = GPBObjCClass(EthereumDefinitions),
        .number = EthereumSignTx_FieldNumber_Definitions,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(EthereumSignTx__storage_, definitions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTx)
                                   messageName:@"EthereumSignTx"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTx__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTxEIP1559

@implementation EthereumSignTxEIP1559

@dynamic addressNArray, addressNArray_Count;
@dynamic hasNonce, nonce;
@dynamic hasMaxGasFee, maxGasFee;
@dynamic hasMaxPriorityFee, maxPriorityFee;
@dynamic hasGasLimit, gasLimit;
@dynamic hasTo, to;
@dynamic hasValue, value;
@dynamic hasDataInitialChunk, dataInitialChunk;
@dynamic hasDataLength, dataLength;
@dynamic hasChainId, chainId;
@dynamic accessListArray, accessListArray_Count;
@dynamic hasDefinitions, definitions;

typedef struct EthereumSignTxEIP1559__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  GPBUInt32Array *addressNArray;
  NSData *nonce;
  NSData *maxGasFee;
  NSData *maxPriorityFee;
  NSData *gasLimit;
  NSString *to;
  NSData *value;
  NSData *dataInitialChunk;
  NSMutableArray *accessListArray;
  EthereumDefinitions *definitions;
  uint64_t chainId;
} EthereumSignTxEIP1559__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, nonce),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxGasFee",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_MaxGasFee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, maxGasFee),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxPriorityFee",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_MaxPriorityFee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, maxPriorityFee),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "gasLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_GasLimit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, gasLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "to",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_To,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, to),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_Value,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataInitialChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_DataInitialChunk,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, dataInitialChunk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_DataLength,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, dataLength),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_FieldNumber_ChainId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, chainId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "accessListArray",
        .dataTypeSpecific.clazz = GPBObjCClass(EthereumSignTxEIP1559_EthereumAccessList),
        .number = EthereumSignTxEIP1559_FieldNumber_AccessListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, accessListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "definitions",
        .dataTypeSpecific.clazz = GPBObjCClass(EthereumDefinitions),
        .number = EthereumSignTxEIP1559_FieldNumber_Definitions,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559__storage_, definitions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTxEIP1559)
                                   messageName:@"EthereumSignTxEIP1559"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTxEIP1559__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTxEIP1559_EthereumAccessList

@implementation EthereumSignTxEIP1559_EthereumAccessList

@dynamic hasAddress, address;
@dynamic storageKeysArray, storageKeysArray_Count;

typedef struct EthereumSignTxEIP1559_EthereumAccessList__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSMutableArray *storageKeysArray;
} EthereumSignTxEIP1559_EthereumAccessList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_EthereumAccessList_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559_EthereumAccessList__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storageKeysArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559_EthereumAccessList_FieldNumber_StorageKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559_EthereumAccessList__storage_, storageKeysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTxEIP1559_EthereumAccessList)
                                   messageName:@"EthereumAccessList"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTxEIP1559_EthereumAccessList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(EthereumSignTxEIP1559)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumTxRequest

@implementation EthereumTxRequest

@dynamic hasDataLength, dataLength;
@dynamic hasSignatureV, signatureV;
@dynamic hasSignatureR, signatureR;
@dynamic hasSignatureS, signatureS;

typedef struct EthereumTxRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  uint32_t signatureV;
  NSData *signatureR;
  NSData *signatureS;
} EthereumTxRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequest_FieldNumber_DataLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumTxRequest__storage_, dataLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signatureV",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequest_FieldNumber_SignatureV,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumTxRequest__storage_, signatureV),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signatureR",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequest_FieldNumber_SignatureR,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumTxRequest__storage_, signatureR),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signatureS",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequest_FieldNumber_SignatureS,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EthereumTxRequest__storage_, signatureS),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumTxRequest)
                                   messageName:@"EthereumTxRequest"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumTxRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumTxAck

@implementation EthereumTxAck

@dynamic hasDataChunk, dataChunk;

typedef struct EthereumTxAck__storage_ {
  uint32_t _has_storage_[1];
  NSData *dataChunk;
} EthereumTxAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxAck_FieldNumber_DataChunk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumTxAck__storage_, dataChunk),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumTxAck)
                                   messageName:@"EthereumTxAck"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumTxAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignMessage

@implementation EthereumSignMessage

@dynamic addressNArray, addressNArray_Count;
@dynamic hasMessage, message;
@dynamic hasEncodedNetwork, encodedNetwork;

typedef struct EthereumSignMessage__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  NSData *message;
  NSData *encodedNetwork;
} EthereumSignMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessage_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignMessage__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessage_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignMessage__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "encodedNetwork",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessage_FieldNumber_EncodedNetwork,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignMessage__storage_, encodedNetwork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignMessage)
                                   messageName:@"EthereumSignMessage"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumMessageSignature

@implementation EthereumMessageSignature

@dynamic hasSignature, signature;
@dynamic hasAddress, address;

typedef struct EthereumMessageSignature__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSString *address;
} EthereumMessageSignature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumMessageSignature_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumMessageSignature__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumMessageSignature_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumMessageSignature__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumMessageSignature)
                                   messageName:@"EthereumMessageSignature"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumMessageSignature__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumVerifyMessage

@implementation EthereumVerifyMessage

@dynamic hasSignature, signature;
@dynamic hasMessage, message;
@dynamic hasAddress, address;

typedef struct EthereumVerifyMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSData *message;
  NSString *address;
} EthereumVerifyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumVerifyMessage_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumVerifyMessage__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumVerifyMessage_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumVerifyMessage__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumVerifyMessage_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumVerifyMessage__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumVerifyMessage)
                                   messageName:@"EthereumVerifyMessage"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumVerifyMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTypedHash

@implementation EthereumSignTypedHash

@dynamic addressNArray, addressNArray_Count;
@dynamic hasDomainSeparatorHash, domainSeparatorHash;
@dynamic hasMessageHash, messageHash;
@dynamic hasEncodedNetwork, encodedNetwork;

typedef struct EthereumSignTypedHash__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  NSData *domainSeparatorHash;
  NSData *messageHash;
  NSData *encodedNetwork;
} EthereumSignTypedHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHash_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTypedHash__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "domainSeparatorHash",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHash_FieldNumber_DomainSeparatorHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTypedHash__storage_, domainSeparatorHash),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "messageHash",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHash_FieldNumber_MessageHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignTypedHash__storage_, messageHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "encodedNetwork",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHash_FieldNumber_EncodedNetwork,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumSignTypedHash__storage_, encodedNetwork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTypedHash)
                                   messageName:@"EthereumSignTypedHash"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTypedHash__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumTypedDataSignature

@implementation EthereumTypedDataSignature

@dynamic hasSignature, signature;
@dynamic hasAddress, address;

typedef struct EthereumTypedDataSignature__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSString *address;
} EthereumTypedDataSignature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTypedDataSignature_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumTypedDataSignature__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTypedDataSignature_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumTypedDataSignature__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumTypedDataSignature)
                                   messageName:@"EthereumTypedDataSignature"
                               fileDescription:&MessagesEthereumRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumTypedDataSignature__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
