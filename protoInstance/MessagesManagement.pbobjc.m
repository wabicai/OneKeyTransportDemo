// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: messages-management.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "MessagesManagement.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(ApplyFlags);
GPBObjCClassDeclaration(ApplySettings);
GPBObjCClassDeclaration(BackupDevice);
GPBObjCClassDeclaration(BixinBackupAck);
GPBObjCClassDeclaration(BixinBackupDevice);
GPBObjCClassDeclaration(BixinBackupDeviceAck);
GPBObjCClassDeclaration(BixinBackupRequest);
GPBObjCClassDeclaration(BixinLoadDevice);
GPBObjCClassDeclaration(BixinMessageSE);
GPBObjCClassDeclaration(BixinOutMessageSE);
GPBObjCClassDeclaration(BixinRestoreAck);
GPBObjCClassDeclaration(BixinRestoreRequest);
GPBObjCClassDeclaration(BixinSeedOperate);
GPBObjCClassDeclaration(BixinVerifyDeviceAck);
GPBObjCClassDeclaration(BixinVerifyDeviceRequest);
GPBObjCClassDeclaration(BixinWhiteListAck);
GPBObjCClassDeclaration(BixinWhiteListRequest);
GPBObjCClassDeclaration(Cancel);
GPBObjCClassDeclaration(CancelAuthorization);
GPBObjCClassDeclaration(ChangePin);
GPBObjCClassDeclaration(ChangeWipeCode);
GPBObjCClassDeclaration(DeviceBackToBoot);
GPBObjCClassDeclaration(DeviceEraseSector);
GPBObjCClassDeclaration(DeviceInfo);
GPBObjCClassDeclaration(DeviceInfoSettings);
GPBObjCClassDeclaration(DoPreauthorized);
GPBObjCClassDeclaration(EndSession);
GPBObjCClassDeclaration(Entropy);
GPBObjCClassDeclaration(EntropyAck);
GPBObjCClassDeclaration(EntropyRequest);
GPBObjCClassDeclaration(Features);
GPBObjCClassDeclaration(FileInfoList);
GPBObjCClassDeclaration(FileInfoList_FileInfo);
GPBObjCClassDeclaration(GetDeviceInfo);
GPBObjCClassDeclaration(GetEntropy);
GPBObjCClassDeclaration(GetFeatures);
GPBObjCClassDeclaration(GetNextU2FCounter);
GPBObjCClassDeclaration(Initialize);
GPBObjCClassDeclaration(ListResDir);
GPBObjCClassDeclaration(LoadDevice);
GPBObjCClassDeclaration(LockDevice);
GPBObjCClassDeclaration(NFTWriteData);
GPBObjCClassDeclaration(NFTWriteInfo);
GPBObjCClassDeclaration(NextU2FCounter);
GPBObjCClassDeclaration(OnekeyFeatures);
GPBObjCClassDeclaration(OnekeyGetFeatures);
GPBObjCClassDeclaration(Ping);
GPBObjCClassDeclaration(PreauthorizedRequest);
GPBObjCClassDeclaration(ReadSEPublicCert);
GPBObjCClassDeclaration(ReadSEPublicKey);
GPBObjCClassDeclaration(RebootToBoardloader);
GPBObjCClassDeclaration(RebootToBootloader);
GPBObjCClassDeclaration(RecoveryDevice);
GPBObjCClassDeclaration(ResetDevice);
GPBObjCClassDeclaration(ResourceAck);
GPBObjCClassDeclaration(ResourceRequest);
GPBObjCClassDeclaration(ResourceUpdate);
GPBObjCClassDeclaration(ResourceUpload);
GPBObjCClassDeclaration(SEMessageSignature);
GPBObjCClassDeclaration(SEPublicCert);
GPBObjCClassDeclaration(SEPublicKey);
GPBObjCClassDeclaration(SESignMessage);
GPBObjCClassDeclaration(SdProtect);
GPBObjCClassDeclaration(SetU2FCounter);
GPBObjCClassDeclaration(SpiFlashData);
GPBObjCClassDeclaration(SpiFlashRead);
GPBObjCClassDeclaration(SpiFlashWrite);
GPBObjCClassDeclaration(WipeDevice);
GPBObjCClassDeclaration(WordAck);
GPBObjCClassDeclaration(WordRequest);
GPBObjCClassDeclaration(WriteSEPublicCert);
GPBObjCClassDeclaration(ZoomRequest);

#pragma mark - MessagesManagementRoot

@implementation MessagesManagementRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription MessagesManagementRoot_FileDescription = {
  .package = "hw.trezor.messages.management",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto2
};

#pragma mark - Enum BackupType

GPBEnumDescriptor *BackupType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Bip39\000Slip39Basic\000Slip39Advanced\000";
    static const int32_t values[] = {
        BackupType_Bip39,
        BackupType_Slip39Basic,
        BackupType_Slip39Advanced,
    };
    static const char *extraTextFormatInfo = "\003\000\005\000\001\006\205\000\002\006\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BackupType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BackupType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BackupType_IsValidValue(int32_t value__) {
  switch (value__) {
    case BackupType_Bip39:
    case BackupType_Slip39Basic:
    case BackupType_Slip39Advanced:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SafetyCheckLevel

GPBEnumDescriptor *SafetyCheckLevel_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Strict\000PromptAlways\000PromptTemporarily\000";
    static const int32_t values[] = {
        SafetyCheckLevel_Strict,
        SafetyCheckLevel_PromptAlways,
        SafetyCheckLevel_PromptTemporarily,
    };
    static const char *extraTextFormatInfo = "\003\000\006\000\001\014\000\002\021\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SafetyCheckLevel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SafetyCheckLevel_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SafetyCheckLevel_IsValidValue(int32_t value__) {
  switch (value__) {
    case SafetyCheckLevel_Strict:
    case SafetyCheckLevel_PromptAlways:
    case SafetyCheckLevel_PromptTemporarily:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OneKeyDeviceType

GPBEnumDescriptor *OneKeyDeviceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Classic\000Classic1S\000Mini\000Touch\000Pro\000";
    static const int32_t values[] = {
        OneKeyDeviceType_Classic,
        OneKeyDeviceType_Classic1S,
        OneKeyDeviceType_Mini,
        OneKeyDeviceType_Touch,
        OneKeyDeviceType_Pro,
    };
    static const char *extraTextFormatInfo = "\001\001g\002\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OneKeyDeviceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OneKeyDeviceType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OneKeyDeviceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OneKeyDeviceType_Classic:
    case OneKeyDeviceType_Classic1S:
    case OneKeyDeviceType_Mini:
    case OneKeyDeviceType_Touch:
    case OneKeyDeviceType_Pro:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OneKeySeType

GPBEnumDescriptor *OneKeySeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Thd89\000Se608A\000";
    static const int32_t values[] = {
        OneKeySeType_Thd89,
        OneKeySeType_Se608A,
    };
    static const char *extraTextFormatInfo = "\001\001b\004\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OneKeySeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OneKeySeType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OneKeySeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case OneKeySeType_Thd89:
    case OneKeySeType_Se608A:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OneKeySEState

GPBEnumDescriptor *OneKeySEState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Boot\000App\000";
    static const int32_t values[] = {
        OneKeySEState_Boot,
        OneKeySEState_App,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OneKeySEState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OneKeySEState_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OneKeySEState_IsValidValue(int32_t value__) {
  switch (value__) {
    case OneKeySEState_Boot:
    case OneKeySEState_App:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Features_Capability

GPBEnumDescriptor *Features_Capability_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "CapabilityBitcoin\000CapabilityBitcoinLike\000"
        "CapabilityBinance\000CapabilityCardano\000Capa"
        "bilityCrypto\000CapabilityEos\000CapabilityEth"
        "ereum\000CapabilityLisk\000CapabilityMonero\000Ca"
        "pabilityNem\000CapabilityRipple\000CapabilityS"
        "tellar\000CapabilityTezos\000CapabilityU2F\000Cap"
        "abilityShamir\000CapabilityShamirGroups\000Cap"
        "abilityPassphraseEntry\000";
    static const int32_t values[] = {
        Features_Capability_CapabilityBitcoin,
        Features_Capability_CapabilityBitcoinLike,
        Features_Capability_CapabilityBinance,
        Features_Capability_CapabilityCardano,
        Features_Capability_CapabilityCrypto,
        Features_Capability_CapabilityEos,
        Features_Capability_CapabilityEthereum,
        Features_Capability_CapabilityLisk,
        Features_Capability_CapabilityMonero,
        Features_Capability_CapabilityNem,
        Features_Capability_CapabilityRipple,
        Features_Capability_CapabilityStellar,
        Features_Capability_CapabilityTezos,
        Features_Capability_CapabilityU2F,
        Features_Capability_CapabilityShamir,
        Features_Capability_CapabilityShamirGroups,
        Features_Capability_CapabilityPassphraseEntry,
    };
    static const char *extraTextFormatInfo = "\021\000\n\207\000\001\n\207\244\000\002\n\207\000\003\n\207\000\004\n\206\000\005\n\343\000\006\n\210\000\007\n\204\000\010\n\206\000\t\n\343\000\n\n\206\000\013\n\207\000\014\n\205\000\r\n\203\000\016\n\206\000\017\n\214\000\020\n\217\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Features_Capability)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Features_Capability_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Features_Capability_IsValidValue(int32_t value__) {
  switch (value__) {
    case Features_Capability_CapabilityBitcoin:
    case Features_Capability_CapabilityBitcoinLike:
    case Features_Capability_CapabilityBinance:
    case Features_Capability_CapabilityCardano:
    case Features_Capability_CapabilityCrypto:
    case Features_Capability_CapabilityEos:
    case Features_Capability_CapabilityEthereum:
    case Features_Capability_CapabilityLisk:
    case Features_Capability_CapabilityMonero:
    case Features_Capability_CapabilityNem:
    case Features_Capability_CapabilityRipple:
    case Features_Capability_CapabilityStellar:
    case Features_Capability_CapabilityTezos:
    case Features_Capability_CapabilityU2F:
    case Features_Capability_CapabilityShamir:
    case Features_Capability_CapabilityShamirGroups:
    case Features_Capability_CapabilityPassphraseEntry:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ApplySettings_ExportType

GPBEnumDescriptor *ApplySettings_ExportType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "SeedEncExportTypeNo\000SeedEncExportTypeYes"
        "\000MnemonicPlainExportTypeYes\000";
    static const int32_t values[] = {
        ApplySettings_ExportType_SeedEncExportTypeNo,
        ApplySettings_ExportType_SeedEncExportTypeYes,
        ApplySettings_ExportType_MnemonicPlainExportTypeYes,
    };
    static const char *extraTextFormatInfo = "\003\000\021\342\000\001\021\343\000\002\027\343\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ApplySettings_ExportType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ApplySettings_ExportType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ApplySettings_ExportType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ApplySettings_ExportType_SeedEncExportTypeNo:
    case ApplySettings_ExportType_SeedEncExportTypeYes:
    case ApplySettings_ExportType_MnemonicPlainExportTypeYes:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SdProtect_SdProtectOperationType

GPBEnumDescriptor *SdProtect_SdProtectOperationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Disable\000Enable\000Refresh\000";
    static const int32_t values[] = {
        SdProtect_SdProtectOperationType_Disable,
        SdProtect_SdProtectOperationType_Enable,
        SdProtect_SdProtectOperationType_Refresh,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SdProtect_SdProtectOperationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SdProtect_SdProtectOperationType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SdProtect_SdProtectOperationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SdProtect_SdProtectOperationType_Disable:
    case SdProtect_SdProtectOperationType_Enable:
    case SdProtect_SdProtectOperationType_Refresh:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RecoveryDevice_RecoveryDeviceType

GPBEnumDescriptor *RecoveryDevice_RecoveryDeviceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "RecoveryDeviceTypeScrambledWords\000Recover"
        "yDeviceTypeMatrix\000";
    static const int32_t values[] = {
        RecoveryDevice_RecoveryDeviceType_RecoveryDeviceTypeScrambledWords,
        RecoveryDevice_RecoveryDeviceType_RecoveryDeviceTypeMatrix,
    };
    static const char *extraTextFormatInfo = "\002\000\022\216\000\001\022\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RecoveryDevice_RecoveryDeviceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RecoveryDevice_RecoveryDeviceType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RecoveryDevice_RecoveryDeviceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RecoveryDevice_RecoveryDeviceType_RecoveryDeviceTypeScrambledWords:
    case RecoveryDevice_RecoveryDeviceType_RecoveryDeviceTypeMatrix:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum WordRequest_WordRequestType

GPBEnumDescriptor *WordRequest_WordRequestType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "WordRequestTypePlain\000WordRequestTypeMatr"
        "ix9\000WordRequestTypeMatrix6\000";
    static const int32_t values[] = {
        WordRequest_WordRequestType_WordRequestTypePlain,
        WordRequest_WordRequestType_WordRequestTypeMatrix9,
        WordRequest_WordRequestType_WordRequestTypeMatrix6,
    };
    static const char *extraTextFormatInfo = "\003\000\017\205\000\001\017\207\000\002\017\207\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(WordRequest_WordRequestType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:WordRequest_WordRequestType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL WordRequest_WordRequestType_IsValidValue(int32_t value__) {
  switch (value__) {
    case WordRequest_WordRequestType_WordRequestTypePlain:
    case WordRequest_WordRequestType_WordRequestTypeMatrix9:
    case WordRequest_WordRequestType_WordRequestTypeMatrix6:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BixinSeedOperate_SeedRequestType

GPBEnumDescriptor *BixinSeedOperate_SeedRequestType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "SeedRequestTypeGen\000SeedRequestTypeEncExp"
        "ort\000SeedRequestTypeEncImport\000";
    static const int32_t values[] = {
        BixinSeedOperate_SeedRequestType_SeedRequestTypeGen,
        BixinSeedOperate_SeedRequestType_SeedRequestTypeEncExport,
        BixinSeedOperate_SeedRequestType_SeedRequestTypeEncImport,
    };
    static const char *extraTextFormatInfo = "\003\000\017\203\000\001\017\211\000\002\017\211\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BixinSeedOperate_SeedRequestType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BixinSeedOperate_SeedRequestType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BixinSeedOperate_SeedRequestType_IsValidValue(int32_t value__) {
  switch (value__) {
    case BixinSeedOperate_SeedRequestType_SeedRequestTypeGen:
    case BixinSeedOperate_SeedRequestType_SeedRequestTypeEncExport:
    case BixinSeedOperate_SeedRequestType_SeedRequestTypeEncImport:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BixinWhiteListRequest_WL_OperationType

GPBEnumDescriptor *BixinWhiteListRequest_WL_OperationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "WlOperationTypeAdd\000WlOperationTypeDelete"
        "\000WlOperationTypeInquire\000";
    static const int32_t values[] = {
        BixinWhiteListRequest_WL_OperationType_WlOperationTypeAdd,
        BixinWhiteListRequest_WL_OperationType_WlOperationTypeDelete,
        BixinWhiteListRequest_WL_OperationType_WlOperationTypeInquire,
    };
    static const char *extraTextFormatInfo = "\003\000b\215\203\000\001b\215\206\000\002b\215\207\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BixinWhiteListRequest_WL_OperationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BixinWhiteListRequest_WL_OperationType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BixinWhiteListRequest_WL_OperationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case BixinWhiteListRequest_WL_OperationType_WlOperationTypeAdd:
    case BixinWhiteListRequest_WL_OperationType_WlOperationTypeDelete:
    case BixinWhiteListRequest_WL_OperationType_WlOperationTypeInquire:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResourceUpload_ResourceType

GPBEnumDescriptor *ResourceUpload_ResourceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "WallPaper\000Nft\000";
    static const int32_t values[] = {
        ResourceUpload_ResourceType_WallPaper,
        ResourceUpload_ResourceType_Nft,
    };
    static const char *extraTextFormatInfo = "\002\000\t\000\001\003\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResourceUpload_ResourceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResourceUpload_ResourceType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResourceUpload_ResourceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResourceUpload_ResourceType_WallPaper:
    case ResourceUpload_ResourceType_Nft:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Initialize

@implementation Initialize

@dynamic hasSessionId, sessionId;
@dynamic hasSkipPassphrase, skipPassphrase;
@dynamic hasDeriveCardano, deriveCardano;

typedef struct Initialize__storage_ {
  uint32_t _has_storage_[1];
  NSData *sessionId;
} Initialize__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = Initialize_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Initialize__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "skipPassphrase",
        .dataTypeSpecific.clazz = Nil,
        .number = Initialize_FieldNumber_SkipPassphrase,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deriveCardano",
        .dataTypeSpecific.clazz = Nil,
        .number = Initialize_FieldNumber_DeriveCardano,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Initialize)
                                   messageName:@"Initialize"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Initialize__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\204\252\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFeatures

@implementation GetFeatures


typedef struct GetFeatures__storage_ {
  uint32_t _has_storage_[1];
} GetFeatures__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetFeatures)
                                   messageName:@"GetFeatures"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetFeatures__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnekeyGetFeatures

@implementation OnekeyGetFeatures


typedef struct OnekeyGetFeatures__storage_ {
  uint32_t _has_storage_[1];
} OnekeyGetFeatures__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OnekeyGetFeatures)
                                   messageName:@"OnekeyGetFeatures"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(OnekeyGetFeatures__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Features

@implementation Features

@dynamic hasVendor, vendor;
@dynamic hasMajorVersion, majorVersion;
@dynamic hasMinorVersion, minorVersion;
@dynamic hasPatchVersion, patchVersion;
@dynamic hasBootloaderMode, bootloaderMode;
@dynamic hasDeviceId, deviceId;
@dynamic hasPinProtection, pinProtection;
@dynamic hasPassphraseProtection, passphraseProtection;
@dynamic hasLanguage, language;
@dynamic hasLabel, label;
@dynamic hasInitialized_p, initialized_p;
@dynamic hasRevision, revision;
@dynamic hasBootloaderHash, bootloaderHash;
@dynamic hasImported, imported;
@dynamic hasUnlocked, unlocked;
@dynamic hasPassphraseCached, passphraseCached;
@dynamic hasFirmwarePresent, firmwarePresent;
@dynamic hasNeedsBackup, needsBackup;
@dynamic hasFlags, flags;
@dynamic hasModel, model;
@dynamic hasFwMajor, fwMajor;
@dynamic hasFwMinor, fwMinor;
@dynamic hasFwPatch, fwPatch;
@dynamic hasFwVendor, fwVendor;
@dynamic hasUnfinishedBackup, unfinishedBackup;
@dynamic hasNoBackup, noBackup;
@dynamic hasRecoveryMode, recoveryMode;
@dynamic capabilitiesArray, capabilitiesArray_Count;
@dynamic hasBackupType, backupType;
@dynamic hasSdCardPresent, sdCardPresent;
@dynamic hasSdProtection, sdProtection;
@dynamic hasWipeCodeProtection, wipeCodeProtection;
@dynamic hasSessionId, sessionId;
@dynamic hasPassphraseAlwaysOnDevice, passphraseAlwaysOnDevice;
@dynamic hasSafetyChecks, safetyChecks;
@dynamic hasAutoLockDelayMs, autoLockDelayMs;
@dynamic hasDisplayRotation, displayRotation;
@dynamic hasExperimentalFeatures, experimentalFeatures;
@dynamic hasBusy, busy;
@dynamic hasOffset, offset;
@dynamic hasBleName, bleName;
@dynamic hasBleVer, bleVer;
@dynamic hasBleEnable, bleEnable;
@dynamic hasSeEnable, seEnable;
@dynamic hasSeVer, seVer;
@dynamic hasBackupOnly, backupOnly;
@dynamic hasOnekeyVersion, onekeyVersion;
@dynamic hasOnekeySerial, onekeySerial;
@dynamic hasBootloaderVersion, bootloaderVersion;
@dynamic hasSerialNo, serialNo;
@dynamic hasSpiFlash, spiFlash;
@dynamic hasInitstates, initstates;
@dynamic hasNftVoucher, nftVoucher;
@dynamic hasCpuInfo, cpuInfo;
@dynamic hasPreFirmware, preFirmware;
@dynamic hasCoinSwitch, coinSwitch;
@dynamic hasBuildId, buildId;
@dynamic hasBoardloaderVersion, boardloaderVersion;
@dynamic hasBatteryLevel, batteryLevel;
@dynamic hasOnekeyDeviceType, onekeyDeviceType;
@dynamic hasOnekeySeType, onekeySeType;
@dynamic hasOnekeyBoardVersion, onekeyBoardVersion;
@dynamic hasOnekeyBoardHash, onekeyBoardHash;
@dynamic hasOnekeyBootVersion, onekeyBootVersion;
@dynamic hasOnekeyBootHash, onekeyBootHash;
@dynamic hasOnekeySe01Version, onekeySe01Version;
@dynamic hasOnekeySe01Hash, onekeySe01Hash;
@dynamic hasOnekeySe01BuildId, onekeySe01BuildId;
@dynamic hasOnekeyFirmwareVersion, onekeyFirmwareVersion;
@dynamic hasOnekeyFirmwareHash, onekeyFirmwareHash;
@dynamic hasOnekeyFirmwareBuildId, onekeyFirmwareBuildId;
@dynamic hasOnekeySerialNo, onekeySerialNo;
@dynamic hasOnekeyBootBuildId, onekeyBootBuildId;
@dynamic hasOnekeyBleName, onekeyBleName;
@dynamic hasOnekeyBleVersion, onekeyBleVersion;
@dynamic hasOnekeyBleBuildId, onekeyBleBuildId;
@dynamic hasOnekeyBleHash, onekeyBleHash;
@dynamic hasOnekeySe02Version, onekeySe02Version;
@dynamic hasOnekeySe03Version, onekeySe03Version;
@dynamic hasOnekeySe04Version, onekeySe04Version;
@dynamic hasOnekeySe01State, onekeySe01State;
@dynamic hasOnekeySe02State, onekeySe02State;
@dynamic hasOnekeySe03State, onekeySe03State;
@dynamic hasOnekeySe04State, onekeySe04State;

typedef struct Features__storage_ {
  uint32_t _has_storage_[4];
  uint32_t majorVersion;
  uint32_t minorVersion;
  uint32_t patchVersion;
  uint32_t flags;
  uint32_t fwMajor;
  uint32_t fwMinor;
  uint32_t fwPatch;
  BackupType backupType;
  SafetyCheckLevel safetyChecks;
  uint32_t autoLockDelayMs;
  uint32_t displayRotation;
  uint32_t offset;
  uint32_t initstates;
  uint32_t coinSwitch;
  uint32_t batteryLevel;
  OneKeyDeviceType onekeyDeviceType;
  OneKeySeType onekeySeType;
  OneKeySEState onekeySe01State;
  OneKeySEState onekeySe02State;
  OneKeySEState onekeySe03State;
  OneKeySEState onekeySe04State;
  NSString *vendor;
  NSString *deviceId;
  NSString *language;
  NSString *label;
  NSData *revision;
  NSData *bootloaderHash;
  NSString *model;
  NSString *fwVendor;
  GPBEnumArray *capabilitiesArray;
  NSData *sessionId;
  NSString *bleName;
  NSString *bleVer;
  NSString *seVer;
  NSString *onekeyVersion;
  NSString *onekeySerial;
  NSString *bootloaderVersion;
  NSString *serialNo;
  NSString *spiFlash;
  NSData *nftVoucher;
  NSString *cpuInfo;
  NSString *preFirmware;
  NSData *buildId;
  NSString *boardloaderVersion;
  NSString *onekeyBoardVersion;
  NSData *onekeyBoardHash;
  NSString *onekeyBootVersion;
  NSData *onekeyBootHash;
  NSString *onekeySe01Version;
  NSData *onekeySe01Hash;
  NSString *onekeySe01BuildId;
  NSString *onekeyFirmwareVersion;
  NSData *onekeyFirmwareHash;
  NSString *onekeyFirmwareBuildId;
  NSString *onekeySerialNo;
  NSString *onekeyBootBuildId;
  NSString *onekeyBleName;
  NSString *onekeyBleVersion;
  NSString *onekeyBleBuildId;
  NSData *onekeyBleHash;
  NSString *onekeySe02Version;
  NSString *onekeySe03Version;
  NSString *onekeySe04Version;
} Features__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vendor",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Vendor,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Features__storage_, vendor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "majorVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_MajorVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Features__storage_, majorVersion),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "minorVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_MinorVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Features__storage_, minorVersion),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "patchVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_PatchVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Features__storage_, patchVersion),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bootloaderMode",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BootloaderMode,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_DeviceId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Features__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pinProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_PinProtection,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "passphraseProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_PassphraseProtection,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Language,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Features__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Label,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Features__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initialized_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Initialized_p,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "revision",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Revision,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Features__storage_, revision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "bootloaderHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BootloaderHash,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Features__storage_, bootloaderHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "imported",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Imported,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "unlocked",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Unlocked,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "passphraseCached",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_PassphraseCached,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "firmwarePresent",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_FirmwarePresent,
        .hasIndex = 23,
        .offset = 24,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "needsBackup",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_NeedsBackup,
        .hasIndex = 25,
        .offset = 26,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "flags",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Flags,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(Features__storage_, flags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "model",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Model,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(Features__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fwMajor",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_FwMajor,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(Features__storage_, fwMajor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fwMinor",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_FwMinor,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(Features__storage_, fwMinor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fwPatch",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_FwPatch,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(Features__storage_, fwPatch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fwVendor",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_FwVendor,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(Features__storage_, fwVendor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unfinishedBackup",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_UnfinishedBackup,
        .hasIndex = 33,
        .offset = 34,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noBackup",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_NoBackup,
        .hasIndex = 35,
        .offset = 36,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "recoveryMode",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_RecoveryMode,
        .hasIndex = 37,
        .offset = 38,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "capabilitiesArray",
        .dataTypeSpecific.enumDescFunc = Features_Capability_EnumDescriptor,
        .number = Features_FieldNumber_CapabilitiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Features__storage_, capabilitiesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "backupType",
        .dataTypeSpecific.enumDescFunc = BackupType_EnumDescriptor,
        .number = Features_FieldNumber_BackupType,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(Features__storage_, backupType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sdCardPresent",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_SdCardPresent,
        .hasIndex = 40,
        .offset = 41,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sdProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_SdProtection,
        .hasIndex = 42,
        .offset = 43,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "wipeCodeProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_WipeCodeProtection,
        .hasIndex = 44,
        .offset = 45,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_SessionId,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(Features__storage_, sessionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "passphraseAlwaysOnDevice",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_PassphraseAlwaysOnDevice,
        .hasIndex = 47,
        .offset = 48,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "safetyChecks",
        .dataTypeSpecific.enumDescFunc = SafetyCheckLevel_EnumDescriptor,
        .number = Features_FieldNumber_SafetyChecks,
        .hasIndex = 49,
        .offset = (uint32_t)offsetof(Features__storage_, safetyChecks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "autoLockDelayMs",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_AutoLockDelayMs,
        .hasIndex = 50,
        .offset = (uint32_t)offsetof(Features__storage_, autoLockDelayMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "displayRotation",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_DisplayRotation,
        .hasIndex = 51,
        .offset = (uint32_t)offsetof(Features__storage_, displayRotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "experimentalFeatures",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_ExperimentalFeatures,
        .hasIndex = 52,
        .offset = 53,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "busy",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Busy,
        .hasIndex = 54,
        .offset = 55,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Offset,
        .hasIndex = 56,
        .offset = (uint32_t)offsetof(Features__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bleName",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BleName,
        .hasIndex = 57,
        .offset = (uint32_t)offsetof(Features__storage_, bleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bleVer",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BleVer,
        .hasIndex = 58,
        .offset = (uint32_t)offsetof(Features__storage_, bleVer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bleEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BleEnable,
        .hasIndex = 59,
        .offset = 60,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "seEnable",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_SeEnable,
        .hasIndex = 61,
        .offset = 62,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "seVer",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_SeVer,
        .hasIndex = 63,
        .offset = (uint32_t)offsetof(Features__storage_, seVer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backupOnly",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BackupOnly,
        .hasIndex = 64,
        .offset = 65,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "onekeyVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyVersion,
        .hasIndex = 66,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySerial",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySerial,
        .hasIndex = 67,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySerial),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bootloaderVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BootloaderVersion,
        .hasIndex = 68,
        .offset = (uint32_t)offsetof(Features__storage_, bootloaderVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serialNo",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_SerialNo,
        .hasIndex = 69,
        .offset = (uint32_t)offsetof(Features__storage_, serialNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spiFlash",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_SpiFlash,
        .hasIndex = 70,
        .offset = (uint32_t)offsetof(Features__storage_, spiFlash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initstates",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_Initstates,
        .hasIndex = 71,
        .offset = (uint32_t)offsetof(Features__storage_, initstates),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nftVoucher",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_NftVoucher,
        .hasIndex = 72,
        .offset = (uint32_t)offsetof(Features__storage_, nftVoucher),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cpuInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_CpuInfo,
        .hasIndex = 73,
        .offset = (uint32_t)offsetof(Features__storage_, cpuInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preFirmware",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_PreFirmware,
        .hasIndex = 74,
        .offset = (uint32_t)offsetof(Features__storage_, preFirmware),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coinSwitch",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_CoinSwitch,
        .hasIndex = 75,
        .offset = (uint32_t)offsetof(Features__storage_, coinSwitch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "buildId",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BuildId,
        .hasIndex = 76,
        .offset = (uint32_t)offsetof(Features__storage_, buildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "boardloaderVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BoardloaderVersion,
        .hasIndex = 77,
        .offset = (uint32_t)offsetof(Features__storage_, boardloaderVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "batteryLevel",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_BatteryLevel,
        .hasIndex = 78,
        .offset = (uint32_t)offsetof(Features__storage_, batteryLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "onekeyDeviceType",
        .dataTypeSpecific.enumDescFunc = OneKeyDeviceType_EnumDescriptor,
        .number = Features_FieldNumber_OnekeyDeviceType,
        .hasIndex = 79,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySeType",
        .dataTypeSpecific.enumDescFunc = OneKeySeType_EnumDescriptor,
        .number = Features_FieldNumber_OnekeySeType,
        .hasIndex = 80,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeyBoardVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBoardVersion,
        .hasIndex = 81,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBoardVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBoardHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBoardHash,
        .hasIndex = 82,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBoardHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeyBootVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBootVersion,
        .hasIndex = 83,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBootVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBootHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBootHash,
        .hasIndex = 84,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBootHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe01Version",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySe01Version,
        .hasIndex = 85,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe01Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe01Hash",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySe01Hash,
        .hasIndex = 86,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe01Hash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe01BuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySe01BuildId,
        .hasIndex = 87,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe01BuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyFirmwareVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyFirmwareVersion,
        .hasIndex = 88,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyFirmwareVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyFirmwareHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyFirmwareHash,
        .hasIndex = 89,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyFirmwareHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeyFirmwareBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyFirmwareBuildId,
        .hasIndex = 90,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyFirmwareBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySerialNo",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySerialNo,
        .hasIndex = 91,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySerialNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBootBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBootBuildId,
        .hasIndex = 92,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBootBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleName",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBleName,
        .hasIndex = 93,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBleVersion,
        .hasIndex = 94,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBleVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBleBuildId,
        .hasIndex = 95,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBleBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleHash",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeyBleHash,
        .hasIndex = 96,
        .offset = (uint32_t)offsetof(Features__storage_, onekeyBleHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe02Version",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySe02Version,
        .hasIndex = 97,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe02Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe03Version",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySe03Version,
        .hasIndex = 98,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe03Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe04Version",
        .dataTypeSpecific.clazz = Nil,
        .number = Features_FieldNumber_OnekeySe04Version,
        .hasIndex = 99,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe04Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe01State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = Features_FieldNumber_OnekeySe01State,
        .hasIndex = 100,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe01State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe02State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = Features_FieldNumber_OnekeySe02State,
        .hasIndex = 101,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe02State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe03State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = Features_FieldNumber_OnekeySe03State,
        .hasIndex = 102,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe03State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe04State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = Features_FieldNumber_OnekeySe04State,
        .hasIndex = 103,
        .offset = (uint32_t)offsetof(Features__storage_, onekeySe04State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Features)
                                   messageName:@"Features"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Features__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\021\212\246\000\202\004c\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnekeyFeatures

@implementation OnekeyFeatures

@dynamic hasOnekeyDeviceType, onekeyDeviceType;
@dynamic hasOnekeyBoardVersion, onekeyBoardVersion;
@dynamic hasOnekeyBootVersion, onekeyBootVersion;
@dynamic hasOnekeyFirmwareVersion, onekeyFirmwareVersion;
@dynamic hasOnekeyBoardHash, onekeyBoardHash;
@dynamic hasOnekeyBootHash, onekeyBootHash;
@dynamic hasOnekeyFirmwareHash, onekeyFirmwareHash;
@dynamic hasOnekeyBoardBuildId, onekeyBoardBuildId;
@dynamic hasOnekeyBootBuildId, onekeyBootBuildId;
@dynamic hasOnekeyFirmwareBuildId, onekeyFirmwareBuildId;
@dynamic hasOnekeySerialNo, onekeySerialNo;
@dynamic hasOnekeyBleName, onekeyBleName;
@dynamic hasOnekeyBleVersion, onekeyBleVersion;
@dynamic hasOnekeyBleBuildId, onekeyBleBuildId;
@dynamic hasOnekeyBleHash, onekeyBleHash;
@dynamic hasOnekeySeType, onekeySeType;
@dynamic hasOnekeySe01State, onekeySe01State;
@dynamic hasOnekeySe02State, onekeySe02State;
@dynamic hasOnekeySe03State, onekeySe03State;
@dynamic hasOnekeySe04State, onekeySe04State;
@dynamic hasOnekeySe01Version, onekeySe01Version;
@dynamic hasOnekeySe02Version, onekeySe02Version;
@dynamic hasOnekeySe03Version, onekeySe03Version;
@dynamic hasOnekeySe04Version, onekeySe04Version;
@dynamic hasOnekeySe01Hash, onekeySe01Hash;
@dynamic hasOnekeySe02Hash, onekeySe02Hash;
@dynamic hasOnekeySe03Hash, onekeySe03Hash;
@dynamic hasOnekeySe04Hash, onekeySe04Hash;
@dynamic hasOnekeySe01BuildId, onekeySe01BuildId;
@dynamic hasOnekeySe02BuildId, onekeySe02BuildId;
@dynamic hasOnekeySe03BuildId, onekeySe03BuildId;
@dynamic hasOnekeySe04BuildId, onekeySe04BuildId;
@dynamic hasOnekeySe01BootVersion, onekeySe01BootVersion;
@dynamic hasOnekeySe02BootVersion, onekeySe02BootVersion;
@dynamic hasOnekeySe03BootVersion, onekeySe03BootVersion;
@dynamic hasOnekeySe04BootVersion, onekeySe04BootVersion;
@dynamic hasOnekeySe01BootHash, onekeySe01BootHash;
@dynamic hasOnekeySe02BootHash, onekeySe02BootHash;
@dynamic hasOnekeySe03BootHash, onekeySe03BootHash;
@dynamic hasOnekeySe04BootHash, onekeySe04BootHash;
@dynamic hasOnekeySe01BootBuildId, onekeySe01BootBuildId;
@dynamic hasOnekeySe02BootBuildId, onekeySe02BootBuildId;
@dynamic hasOnekeySe03BootBuildId, onekeySe03BootBuildId;
@dynamic hasOnekeySe04BootBuildId, onekeySe04BootBuildId;

typedef struct OnekeyFeatures__storage_ {
  uint32_t _has_storage_[2];
  OneKeyDeviceType onekeyDeviceType;
  OneKeySeType onekeySeType;
  OneKeySEState onekeySe01State;
  OneKeySEState onekeySe02State;
  OneKeySEState onekeySe03State;
  OneKeySEState onekeySe04State;
  NSString *onekeyBoardVersion;
  NSString *onekeyBootVersion;
  NSString *onekeyFirmwareVersion;
  NSData *onekeyBoardHash;
  NSData *onekeyBootHash;
  NSData *onekeyFirmwareHash;
  NSString *onekeyBoardBuildId;
  NSString *onekeyBootBuildId;
  NSString *onekeyFirmwareBuildId;
  NSString *onekeySerialNo;
  NSString *onekeyBleName;
  NSString *onekeyBleVersion;
  NSString *onekeyBleBuildId;
  NSData *onekeyBleHash;
  NSString *onekeySe01Version;
  NSString *onekeySe02Version;
  NSString *onekeySe03Version;
  NSString *onekeySe04Version;
  NSData *onekeySe01Hash;
  NSData *onekeySe02Hash;
  NSData *onekeySe03Hash;
  NSData *onekeySe04Hash;
  NSString *onekeySe01BuildId;
  NSString *onekeySe02BuildId;
  NSString *onekeySe03BuildId;
  NSString *onekeySe04BuildId;
  NSString *onekeySe01BootVersion;
  NSString *onekeySe02BootVersion;
  NSString *onekeySe03BootVersion;
  NSString *onekeySe04BootVersion;
  NSData *onekeySe01BootHash;
  NSData *onekeySe02BootHash;
  NSData *onekeySe03BootHash;
  NSData *onekeySe04BootHash;
  NSString *onekeySe01BootBuildId;
  NSString *onekeySe02BootBuildId;
  NSString *onekeySe03BootBuildId;
  NSString *onekeySe04BootBuildId;
} OnekeyFeatures__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onekeyDeviceType",
        .dataTypeSpecific.enumDescFunc = OneKeyDeviceType_EnumDescriptor,
        .number = OnekeyFeatures_FieldNumber_OnekeyDeviceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeyBoardVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBoardVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBoardVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBootVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBootVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBootVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyFirmwareVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyFirmwareVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyFirmwareVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBoardHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBoardHash,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBoardHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeyBootHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBootHash,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBootHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeyFirmwareHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyFirmwareHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyFirmwareHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeyBoardBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBoardBuildId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBoardBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBootBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBootBuildId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBootBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyFirmwareBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyFirmwareBuildId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyFirmwareBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySerialNo",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySerialNo,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySerialNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleName",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBleName,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBleName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBleVersion,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBleVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBleBuildId,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBleBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeyBleHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeyBleHash,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeyBleHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySeType",
        .dataTypeSpecific.enumDescFunc = OneKeySeType_EnumDescriptor,
        .number = OnekeyFeatures_FieldNumber_OnekeySeType,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySeType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe01State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = OnekeyFeatures_FieldNumber_OnekeySe01State,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe01State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe02State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = OnekeyFeatures_FieldNumber_OnekeySe02State,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe02State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe03State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = OnekeyFeatures_FieldNumber_OnekeySe03State,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe03State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe04State",
        .dataTypeSpecific.enumDescFunc = OneKeySEState_EnumDescriptor,
        .number = OnekeyFeatures_FieldNumber_OnekeySe04State,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe04State),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "onekeySe01Version",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe01Version,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe01Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe02Version",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe02Version,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe02Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe03Version",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe03Version,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe03Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe04Version",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe04Version,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe04Version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe01Hash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe01Hash,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe01Hash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe02Hash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe02Hash,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe02Hash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe03Hash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe03Hash,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe03Hash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe04Hash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe04Hash,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe04Hash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe01BuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe01BuildId,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe01BuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe02BuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe02BuildId,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe02BuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe03BuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe03BuildId,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe03BuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe04BuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe04BuildId,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe04BuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe01BootVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe01BootVersion,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe01BootVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe02BootVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe02BootVersion,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe02BootVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe03BootVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe03BootVersion,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe03BootVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe04BootVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe04BootVersion,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe04BootVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe01BootHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe01BootHash,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe01BootHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe02BootHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe02BootHash,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe02BootHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe03BootHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe03BootHash,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe03BootHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe04BootHash",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe04BootHash,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe04BootHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onekeySe01BootBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe01BootBuildId,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe01BootBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe02BootBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe02BootBuildId,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe02BootBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe03BootBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe03BootBuildId,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe03BootBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onekeySe04BootBuildId",
        .dataTypeSpecific.clazz = Nil,
        .number = OnekeyFeatures_FieldNumber_OnekeySe04BootBuildId,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(OnekeyFeatures__storage_, onekeySe04BootBuildId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(OnekeyFeatures)
                                   messageName:@"OnekeyFeatures"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnekeyFeatures__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LockDevice

@implementation LockDevice


typedef struct LockDevice__storage_ {
  uint32_t _has_storage_[1];
} LockDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(LockDevice)
                                   messageName:@"LockDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LockDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EndSession

@implementation EndSession


typedef struct EndSession__storage_ {
  uint32_t _has_storage_[1];
} EndSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EndSession)
                                   messageName:@"EndSession"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(EndSession__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ApplySettings

@implementation ApplySettings

@dynamic hasLanguage, language;
@dynamic hasLabel, label;
@dynamic hasUsePassphrase, usePassphrase;
@dynamic hasHomescreen, homescreen;
@dynamic hasPassphraseSource, passphraseSource;
@dynamic hasAutoLockDelayMs, autoLockDelayMs;
@dynamic hasDisplayRotation, displayRotation;
@dynamic hasPassphraseAlwaysOnDevice, passphraseAlwaysOnDevice;
@dynamic hasSafetyChecks, safetyChecks;
@dynamic hasExperimentalFeatures, experimentalFeatures;
@dynamic hasUseBle, useBle;
@dynamic hasUseSe, useSe;
@dynamic hasIsBixinapp, isBixinapp;
@dynamic hasFastpayPin, fastpayPin;
@dynamic hasFastpayConfirm, fastpayConfirm;
@dynamic hasFastpayMoneyLimit, fastpayMoneyLimit;
@dynamic hasFastpayTimes, fastpayTimes;

typedef struct ApplySettings__storage_ {
  uint32_t _has_storage_[1];
  uint32_t passphraseSource;
  uint32_t autoLockDelayMs;
  uint32_t displayRotation;
  SafetyCheckLevel safetyChecks;
  uint32_t fastpayTimes;
  NSString *language;
  NSString *label;
  NSData *homescreen;
  uint64_t fastpayMoneyLimit;
} ApplySettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_Language,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "usePassphrase",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_UsePassphrase,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "homescreen",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_Homescreen,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, homescreen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "passphraseSource",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_PassphraseSource,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, passphraseSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "autoLockDelayMs",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_AutoLockDelayMs,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, autoLockDelayMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "displayRotation",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_DisplayRotation,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, displayRotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "passphraseAlwaysOnDevice",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_PassphraseAlwaysOnDevice,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "safetyChecks",
        .dataTypeSpecific.enumDescFunc = SafetyCheckLevel_EnumDescriptor,
        .number = ApplySettings_FieldNumber_SafetyChecks,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, safetyChecks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "experimentalFeatures",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_ExperimentalFeatures,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "useBle",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_UseBle,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "useSe",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_UseSe,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isBixinapp",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_IsBixinapp,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fastpayPin",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_FastpayPin,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fastpayConfirm",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_FastpayConfirm,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fastpayMoneyLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_FastpayMoneyLimit,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, fastpayMoneyLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fastpayTimes",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplySettings_FieldNumber_FastpayTimes,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ApplySettings__storage_, fastpayTimes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ApplySettings)
                                   messageName:@"ApplySettings"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ApplySettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\005\212\246\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ApplyFlags

@implementation ApplyFlags

@dynamic hasFlags, flags;

typedef struct ApplyFlags__storage_ {
  uint32_t _has_storage_[1];
  uint32_t flags;
} ApplyFlags__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "flags",
        .dataTypeSpecific.clazz = Nil,
        .number = ApplyFlags_FieldNumber_Flags,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ApplyFlags__storage_, flags),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ApplyFlags)
                                   messageName:@"ApplyFlags"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ApplyFlags__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangePin

@implementation ChangePin

@dynamic hasRemove, remove;

typedef struct ChangePin__storage_ {
  uint32_t _has_storage_[1];
} ChangePin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remove",
        .dataTypeSpecific.clazz = Nil,
        .number = ChangePin_FieldNumber_Remove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChangePin)
                                   messageName:@"ChangePin"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangePin__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeWipeCode

@implementation ChangeWipeCode

@dynamic hasRemove, remove;

typedef struct ChangeWipeCode__storage_ {
  uint32_t _has_storage_[1];
} ChangeWipeCode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remove",
        .dataTypeSpecific.clazz = Nil,
        .number = ChangeWipeCode_FieldNumber_Remove,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ChangeWipeCode)
                                   messageName:@"ChangeWipeCode"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeWipeCode__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SdProtect

@implementation SdProtect

@dynamic hasOperation, operation;

typedef struct SdProtect__storage_ {
  uint32_t _has_storage_[1];
  SdProtect_SdProtectOperationType operation;
} SdProtect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "operation",
        .dataTypeSpecific.enumDescFunc = SdProtect_SdProtectOperationType_EnumDescriptor,
        .number = SdProtect_FieldNumber_Operation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SdProtect__storage_, operation),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SdProtect)
                                   messageName:@"SdProtect"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SdProtect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ping

@implementation Ping

@dynamic hasMessage, message;
@dynamic hasButtonProtection, buttonProtection;

typedef struct Ping__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} Ping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Ping__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buttonProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = Ping_FieldNumber_ButtonProtection,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Ping)
                                   messageName:@"Ping"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ping__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Cancel

@implementation Cancel


typedef struct Cancel__storage_ {
  uint32_t _has_storage_[1];
} Cancel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Cancel)
                                   messageName:@"Cancel"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Cancel__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEntropy

@implementation GetEntropy

@dynamic hasSize, size;

typedef struct GetEntropy__storage_ {
  uint32_t _has_storage_[1];
  uint32_t size;
} GetEntropy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = GetEntropy_FieldNumber_Size,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEntropy__storage_, size),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetEntropy)
                                   messageName:@"GetEntropy"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEntropy__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Entropy

@implementation Entropy

@dynamic hasEntropy, entropy;

typedef struct Entropy__storage_ {
  uint32_t _has_storage_[1];
  NSData *entropy;
} Entropy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entropy",
        .dataTypeSpecific.clazz = Nil,
        .number = Entropy_FieldNumber_Entropy,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Entropy__storage_, entropy),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Entropy)
                                   messageName:@"Entropy"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Entropy__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WipeDevice

@implementation WipeDevice


typedef struct WipeDevice__storage_ {
  uint32_t _has_storage_[1];
} WipeDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(WipeDevice)
                                   messageName:@"WipeDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(WipeDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoadDevice

@implementation LoadDevice

@dynamic mnemonicsArray, mnemonicsArray_Count;
@dynamic hasPin, pin;
@dynamic hasPassphraseProtection, passphraseProtection;
@dynamic hasLanguage, language;
@dynamic hasLabel, label;
@dynamic hasSkipChecksum, skipChecksum;
@dynamic hasU2FCounter, u2FCounter;
@dynamic hasNeedsBackup, needsBackup;
@dynamic hasNoBackup, noBackup;

typedef struct LoadDevice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t u2FCounter;
  NSMutableArray *mnemonicsArray;
  NSString *pin;
  NSString *language;
  NSString *label;
} LoadDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "mnemonicsArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_MnemonicsArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(LoadDevice__storage_, mnemonicsArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "pin",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_Pin,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(LoadDevice__storage_, pin),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "passphraseProtection",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_PassphraseProtection,
        .core.hasIndex = 1,
        .core.offset = 2,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueString = @"en-US",
        .core.name = "language",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_Language,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(LoadDevice__storage_, language),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "label",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_Label,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(LoadDevice__storage_, label),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "skipChecksum",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_SkipChecksum,
        .core.hasIndex = 5,
        .core.offset = 6,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "u2FCounter",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_U2FCounter,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(LoadDevice__storage_, u2FCounter),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "needsBackup",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_NeedsBackup,
        .core.hasIndex = 8,
        .core.offset = 9,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "noBackup",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = LoadDevice_FieldNumber_NoBackup,
        .core.hasIndex = 10,
        .core.offset = 11,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(LoadDevice)
                                   messageName:@"LoadDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(LoadDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\010\002!\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetDevice

@implementation ResetDevice

@dynamic hasDisplayRandom, displayRandom;
@dynamic hasStrength, strength;
@dynamic hasPassphraseProtection, passphraseProtection;
@dynamic hasPinProtection, pinProtection;
@dynamic hasLanguage, language;
@dynamic hasLabel, label;
@dynamic hasU2FCounter, u2FCounter;
@dynamic hasSkipBackup, skipBackup;
@dynamic hasNoBackup, noBackup;
@dynamic hasBackupType, backupType;

typedef struct ResetDevice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t strength;
  uint32_t u2FCounter;
  BackupType backupType;
  NSString *language;
  NSString *label;
} ResetDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueBool = NO,
        .core.name = "displayRandom",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_DisplayRandom,
        .core.hasIndex = 0,
        .core.offset = 1,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 256U,
        .core.name = "strength",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_Strength,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ResetDevice__storage_, strength),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "passphraseProtection",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_PassphraseProtection,
        .core.hasIndex = 3,
        .core.offset = 4,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "pinProtection",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_PinProtection,
        .core.hasIndex = 5,
        .core.offset = 6,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueString = @"en-US",
        .core.name = "language",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_Language,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ResetDevice__storage_, language),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "label",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_Label,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ResetDevice__storage_, label),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "u2FCounter",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_U2FCounter,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(ResetDevice__storage_, u2FCounter),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "skipBackup",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_SkipBackup,
        .core.hasIndex = 10,
        .core.offset = 11,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "noBackup",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ResetDevice_FieldNumber_NoBackup,
        .core.hasIndex = 12,
        .core.offset = 13,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueEnum = BackupType_Bip39,
        .core.name = "backupType",
        .core.dataTypeSpecific.enumDescFunc = BackupType_EnumDescriptor,
        .core.number = ResetDevice_FieldNumber_BackupType,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(ResetDevice__storage_, backupType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResetDevice)
                                   messageName:@"ResetDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ResetDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\007\002!\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupDevice

@implementation BackupDevice


typedef struct BackupDevice__storage_ {
  uint32_t _has_storage_[1];
} BackupDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BackupDevice)
                                   messageName:@"BackupDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(BackupDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EntropyRequest

@implementation EntropyRequest


typedef struct EntropyRequest__storage_ {
  uint32_t _has_storage_[1];
} EntropyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EntropyRequest)
                                   messageName:@"EntropyRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(EntropyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EntropyAck

@implementation EntropyAck

@dynamic hasEntropy, entropy;

typedef struct EntropyAck__storage_ {
  uint32_t _has_storage_[1];
  NSData *entropy;
} EntropyAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "entropy",
        .dataTypeSpecific.clazz = Nil,
        .number = EntropyAck_FieldNumber_Entropy,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EntropyAck__storage_, entropy),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EntropyAck)
                                   messageName:@"EntropyAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EntropyAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RecoveryDevice

@implementation RecoveryDevice

@dynamic hasWordCount, wordCount;
@dynamic hasPassphraseProtection, passphraseProtection;
@dynamic hasPinProtection, pinProtection;
@dynamic hasLanguage, language;
@dynamic hasLabel, label;
@dynamic hasEnforceWordlist, enforceWordlist;
@dynamic hasType, type;
@dynamic hasU2FCounter, u2FCounter;
@dynamic hasDryRun, dryRun;

typedef struct RecoveryDevice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t wordCount;
  RecoveryDevice_RecoveryDeviceType type;
  uint32_t u2FCounter;
  NSString *language;
  NSString *label;
} RecoveryDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wordCount",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_WordCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RecoveryDevice__storage_, wordCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "passphraseProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_PassphraseProtection,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pinProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_PinProtection,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_Language,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RecoveryDevice__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_Label,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RecoveryDevice__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "enforceWordlist",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_EnforceWordlist,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RecoveryDevice_RecoveryDeviceType_EnumDescriptor,
        .number = RecoveryDevice_FieldNumber_Type,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RecoveryDevice__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "u2FCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_U2FCounter,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RecoveryDevice__storage_, u2FCounter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dryRun",
        .dataTypeSpecific.clazz = Nil,
        .number = RecoveryDevice_FieldNumber_DryRun,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RecoveryDevice)
                                   messageName:@"RecoveryDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RecoveryDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\t\002!\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WordRequest

@implementation WordRequest

@dynamic hasType, type;

typedef struct WordRequest__storage_ {
  uint32_t _has_storage_[1];
  WordRequest_WordRequestType type;
} WordRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = WordRequest_WordRequestType_EnumDescriptor,
        .number = WordRequest_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WordRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(WordRequest)
                                   messageName:@"WordRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WordRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WordAck

@implementation WordAck

@dynamic hasWord, word;

typedef struct WordAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *word;
} WordAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "word",
        .dataTypeSpecific.clazz = Nil,
        .number = WordAck_FieldNumber_Word,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WordAck__storage_, word),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(WordAck)
                                   messageName:@"WordAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WordAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetU2FCounter

@implementation SetU2FCounter

@dynamic hasU2FCounter, u2FCounter;

typedef struct SetU2FCounter__storage_ {
  uint32_t _has_storage_[1];
  uint32_t u2FCounter;
} SetU2FCounter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "u2FCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = SetU2FCounter_FieldNumber_U2FCounter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetU2FCounter__storage_, u2FCounter),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SetU2FCounter)
                                   messageName:@"SetU2FCounter"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetU2FCounter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\002!\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNextU2FCounter

@implementation GetNextU2FCounter


typedef struct GetNextU2FCounter__storage_ {
  uint32_t _has_storage_[1];
} GetNextU2FCounter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetNextU2FCounter)
                                   messageName:@"GetNextU2FCounter"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetNextU2FCounter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NextU2FCounter

@implementation NextU2FCounter

@dynamic hasU2FCounter, u2FCounter;

typedef struct NextU2FCounter__storage_ {
  uint32_t _has_storage_[1];
  uint32_t u2FCounter;
} NextU2FCounter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "u2FCounter",
        .dataTypeSpecific.clazz = Nil,
        .number = NextU2FCounter_FieldNumber_U2FCounter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NextU2FCounter__storage_, u2FCounter),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NextU2FCounter)
                                   messageName:@"NextU2FCounter"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NextU2FCounter__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\002!\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DoPreauthorized

@implementation DoPreauthorized


typedef struct DoPreauthorized__storage_ {
  uint32_t _has_storage_[1];
} DoPreauthorized__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DoPreauthorized)
                                   messageName:@"DoPreauthorized"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DoPreauthorized__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PreauthorizedRequest

@implementation PreauthorizedRequest


typedef struct PreauthorizedRequest__storage_ {
  uint32_t _has_storage_[1];
} PreauthorizedRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PreauthorizedRequest)
                                   messageName:@"PreauthorizedRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PreauthorizedRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CancelAuthorization

@implementation CancelAuthorization


typedef struct CancelAuthorization__storage_ {
  uint32_t _has_storage_[1];
} CancelAuthorization__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(CancelAuthorization)
                                   messageName:@"CancelAuthorization"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(CancelAuthorization__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinSeedOperate

@implementation BixinSeedOperate

@dynamic hasType, type;
@dynamic hasSeedImportData, seedImportData;

typedef struct BixinSeedOperate__storage_ {
  uint32_t _has_storage_[1];
  BixinSeedOperate_SeedRequestType type;
  NSData *seedImportData;
} BixinSeedOperate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BixinSeedOperate_SeedRequestType_EnumDescriptor,
        .number = BixinSeedOperate_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinSeedOperate__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "seedImportData",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinSeedOperate_FieldNumber_SeedImportData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BixinSeedOperate__storage_, seedImportData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinSeedOperate)
                                   messageName:@"BixinSeedOperate"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinSeedOperate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\004\252\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinMessageSE

@implementation BixinMessageSE

@dynamic hasInputmessage, inputmessage;

typedef struct BixinMessageSE__storage_ {
  uint32_t _has_storage_[1];
  NSData *inputmessage;
} BixinMessageSE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputmessage",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinMessageSE_FieldNumber_Inputmessage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinMessageSE__storage_, inputmessage),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinMessageSE)
                                   messageName:@"BixinMessageSE"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinMessageSE__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinOutMessageSE

@implementation BixinOutMessageSE

@dynamic hasOutmessage, outmessage;

typedef struct BixinOutMessageSE__storage_ {
  uint32_t _has_storage_[1];
  NSData *outmessage;
} BixinOutMessageSE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outmessage",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinOutMessageSE_FieldNumber_Outmessage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinOutMessageSE__storage_, outmessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinOutMessageSE)
                                   messageName:@"BixinOutMessageSE"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinOutMessageSE__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceBackToBoot

@implementation DeviceBackToBoot


typedef struct DeviceBackToBoot__storage_ {
  uint32_t _has_storage_[1];
} DeviceBackToBoot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DeviceBackToBoot)
                                   messageName:@"DeviceBackToBoot"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeviceBackToBoot__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinBackupRequest

@implementation BixinBackupRequest


typedef struct BixinBackupRequest__storage_ {
  uint32_t _has_storage_[1];
} BixinBackupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinBackupRequest)
                                   messageName:@"BixinBackupRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(BixinBackupRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinBackupAck

@implementation BixinBackupAck

@dynamic hasData_p, data_p;

typedef struct BixinBackupAck__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} BixinBackupAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinBackupAck_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinBackupAck__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinBackupAck)
                                   messageName:@"BixinBackupAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinBackupAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinRestoreRequest

@implementation BixinRestoreRequest

@dynamic hasData_p, data_p;
@dynamic hasLanguage, language;
@dynamic hasLabel, label;
@dynamic hasPassphraseProtection, passphraseProtection;

typedef struct BixinRestoreRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
  NSString *language;
  NSString *label;
} BixinRestoreRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinRestoreRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinRestoreRequest__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "language",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinRestoreRequest_FieldNumber_Language,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BixinRestoreRequest__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinRestoreRequest_FieldNumber_Label,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BixinRestoreRequest__storage_, label),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "passphraseProtection",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinRestoreRequest_FieldNumber_PassphraseProtection,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinRestoreRequest)
                                   messageName:@"BixinRestoreRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinRestoreRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinRestoreAck

@implementation BixinRestoreAck

@dynamic hasData_p, data_p;

typedef struct BixinRestoreAck__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} BixinRestoreAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinRestoreAck_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinRestoreAck__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinRestoreAck)
                                   messageName:@"BixinRestoreAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinRestoreAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinVerifyDeviceRequest

@implementation BixinVerifyDeviceRequest

@dynamic hasData_p, data_p;

typedef struct BixinVerifyDeviceRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} BixinVerifyDeviceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinVerifyDeviceRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinVerifyDeviceRequest__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinVerifyDeviceRequest)
                                   messageName:@"BixinVerifyDeviceRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinVerifyDeviceRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinVerifyDeviceAck

@implementation BixinVerifyDeviceAck

@dynamic hasCert, cert;
@dynamic hasSignature, signature;

typedef struct BixinVerifyDeviceAck__storage_ {
  uint32_t _has_storage_[1];
  NSData *cert;
  NSData *signature;
} BixinVerifyDeviceAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cert",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinVerifyDeviceAck_FieldNumber_Cert,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinVerifyDeviceAck__storage_, cert),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinVerifyDeviceAck_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BixinVerifyDeviceAck__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinVerifyDeviceAck)
                                   messageName:@"BixinVerifyDeviceAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinVerifyDeviceAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinWhiteListRequest

@implementation BixinWhiteListRequest

@dynamic hasType, type;
@dynamic hasAddrIn, addrIn;

typedef struct BixinWhiteListRequest__storage_ {
  uint32_t _has_storage_[1];
  BixinWhiteListRequest_WL_OperationType type;
  NSString *addrIn;
} BixinWhiteListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BixinWhiteListRequest_WL_OperationType_EnumDescriptor,
        .number = BixinWhiteListRequest_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinWhiteListRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "addrIn",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinWhiteListRequest_FieldNumber_AddrIn,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BixinWhiteListRequest__storage_, addrIn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinWhiteListRequest)
                                   messageName:@"BixinWhiteListRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinWhiteListRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinWhiteListAck

@implementation BixinWhiteListAck

@dynamic addressArray, addressArray_Count;

typedef struct BixinWhiteListAck__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressArray;
} BixinWhiteListAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressArray",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinWhiteListAck_FieldNumber_AddressArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BixinWhiteListAck__storage_, addressArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinWhiteListAck)
                                   messageName:@"BixinWhiteListAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinWhiteListAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinLoadDevice

@implementation BixinLoadDevice

@dynamic hasMnemonics, mnemonics;
@dynamic hasLanguage, language;
@dynamic hasLabel, label;
@dynamic hasSkipChecksum, skipChecksum;

typedef struct BixinLoadDevice__storage_ {
  uint32_t _has_storage_[1];
  NSString *mnemonics;
  NSString *language;
  NSString *label;
} BixinLoadDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "mnemonics",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BixinLoadDevice_FieldNumber_Mnemonics,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(BixinLoadDevice__storage_, mnemonics),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = @"en-US",
        .core.name = "language",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BixinLoadDevice_FieldNumber_Language,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(BixinLoadDevice__storage_, language),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "label",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BixinLoadDevice_FieldNumber_Label,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(BixinLoadDevice__storage_, label),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "skipChecksum",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = BixinLoadDevice_FieldNumber_SkipChecksum,
        .core.hasIndex = 3,
        .core.offset = 4,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinLoadDevice)
                                   messageName:@"BixinLoadDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(BixinLoadDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinBackupDevice

@implementation BixinBackupDevice


typedef struct BixinBackupDevice__storage_ {
  uint32_t _has_storage_[1];
} BixinBackupDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinBackupDevice)
                                   messageName:@"BixinBackupDevice"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(BixinBackupDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinBackupDeviceAck

@implementation BixinBackupDeviceAck

@dynamic hasMnemonics, mnemonics;

typedef struct BixinBackupDeviceAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *mnemonics;
} BixinBackupDeviceAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mnemonics",
        .dataTypeSpecific.clazz = Nil,
        .number = BixinBackupDeviceAck_FieldNumber_Mnemonics,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BixinBackupDeviceAck__storage_, mnemonics),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinBackupDeviceAck)
                                   messageName:@"BixinBackupDeviceAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BixinBackupDeviceAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceInfoSettings

@implementation DeviceInfoSettings

@dynamic hasSerialNo, serialNo;
@dynamic hasCpuInfo, cpuInfo;
@dynamic hasPreFirmware, preFirmware;

typedef struct DeviceInfoSettings__storage_ {
  uint32_t _has_storage_[1];
  NSString *serialNo;
  NSString *cpuInfo;
  NSString *preFirmware;
} DeviceInfoSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serialNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfoSettings_FieldNumber_SerialNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInfoSettings__storage_, serialNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfoSettings_FieldNumber_CpuInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInfoSettings__storage_, cpuInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preFirmware",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfoSettings_FieldNumber_PreFirmware,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInfoSettings__storage_, preFirmware),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DeviceInfoSettings)
                                   messageName:@"DeviceInfoSettings"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInfoSettings__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDeviceInfo

@implementation GetDeviceInfo


typedef struct GetDeviceInfo__storage_ {
  uint32_t _has_storage_[1];
} GetDeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(GetDeviceInfo)
                                   messageName:@"GetDeviceInfo"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetDeviceInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceInfo

@implementation DeviceInfo

@dynamic hasSerialNo, serialNo;
@dynamic hasSpiFlashInfo, spiFlashInfo;
@dynamic hasSeInfo, seInfo;
@dynamic hasNftVoucher, nftVoucher;
@dynamic hasCpuInfo, cpuInfo;
@dynamic hasPreFirmware, preFirmware;

typedef struct DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *serialNo;
  NSString *spiFlashInfo;
  NSString *seInfo;
  NSData *nftVoucher;
  NSString *cpuInfo;
  NSString *preFirmware;
} DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serialNo",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_SerialNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, serialNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spiFlashInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_SpiFlashInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, spiFlashInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "seInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_SeInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, seInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nftVoucher",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_NftVoucher,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, nftVoucher),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cpuInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_CpuInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, cpuInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preFirmware",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_PreFirmware,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, preFirmware),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DeviceInfo)
                                   messageName:@"DeviceInfo"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\003\002\010\244\000\003b\244\000\004c\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReadSEPublicKey

@implementation ReadSEPublicKey


typedef struct ReadSEPublicKey__storage_ {
  uint32_t _has_storage_[1];
} ReadSEPublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ReadSEPublicKey)
                                   messageName:@"ReadSEPublicKey"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ReadSEPublicKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SEPublicKey

@implementation SEPublicKey

@dynamic hasPublicKey, publicKey;

typedef struct SEPublicKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKey;
} SEPublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = SEPublicKey_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SEPublicKey__storage_, publicKey),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SEPublicKey)
                                   messageName:@"SEPublicKey"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SEPublicKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WriteSEPublicCert

@implementation WriteSEPublicCert

@dynamic hasPublicCert, publicCert;

typedef struct WriteSEPublicCert__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicCert;
} WriteSEPublicCert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicCert",
        .dataTypeSpecific.clazz = Nil,
        .number = WriteSEPublicCert_FieldNumber_PublicCert,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WriteSEPublicCert__storage_, publicCert),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(WriteSEPublicCert)
                                   messageName:@"WriteSEPublicCert"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WriteSEPublicCert__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReadSEPublicCert

@implementation ReadSEPublicCert


typedef struct ReadSEPublicCert__storage_ {
  uint32_t _has_storage_[1];
} ReadSEPublicCert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ReadSEPublicCert)
                                   messageName:@"ReadSEPublicCert"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ReadSEPublicCert__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SEPublicCert

@implementation SEPublicCert

@dynamic hasPublicCert, publicCert;

typedef struct SEPublicCert__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicCert;
} SEPublicCert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicCert",
        .dataTypeSpecific.clazz = Nil,
        .number = SEPublicCert_FieldNumber_PublicCert,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SEPublicCert__storage_, publicCert),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SEPublicCert)
                                   messageName:@"SEPublicCert"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SEPublicCert__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpiFlashWrite

@implementation SpiFlashWrite

@dynamic hasAddress, address;
@dynamic hasData_p, data_p;

typedef struct SpiFlashWrite__storage_ {
  uint32_t _has_storage_[1];
  uint32_t address;
  NSData *data_p;
} SpiFlashWrite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = SpiFlashWrite_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpiFlashWrite__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SpiFlashWrite_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpiFlashWrite__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpiFlashWrite)
                                   messageName:@"SpiFlashWrite"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpiFlashWrite__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpiFlashRead

@implementation SpiFlashRead

@dynamic hasAddress, address;
@dynamic hasLen, len;

typedef struct SpiFlashRead__storage_ {
  uint32_t _has_storage_[1];
  uint32_t address;
  uint32_t len;
} SpiFlashRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = SpiFlashRead_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpiFlashRead__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "len",
        .dataTypeSpecific.clazz = Nil,
        .number = SpiFlashRead_FieldNumber_Len,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpiFlashRead__storage_, len),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpiFlashRead)
                                   messageName:@"SpiFlashRead"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpiFlashRead__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpiFlashData

@implementation SpiFlashData

@dynamic hasData_p, data_p;

typedef struct SpiFlashData__storage_ {
  uint32_t _has_storage_[1];
  NSData *data_p;
} SpiFlashData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SpiFlashData_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpiFlashData__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SpiFlashData)
                                   messageName:@"SpiFlashData"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpiFlashData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SESignMessage

@implementation SESignMessage

@dynamic hasMessage, message;

typedef struct SESignMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *message;
} SESignMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = SESignMessage_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SESignMessage__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SESignMessage)
                                   messageName:@"SESignMessage"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SESignMessage__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SEMessageSignature

@implementation SEMessageSignature

@dynamic hasSignature, signature;

typedef struct SEMessageSignature__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
} SEMessageSignature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = SEMessageSignature_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SEMessageSignature__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SEMessageSignature)
                                   messageName:@"SEMessageSignature"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SEMessageSignature__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResourceUpload

@implementation ResourceUpload

@dynamic hasExtension, extension;
@dynamic hasDataLength, dataLength;
@dynamic hasResType, resType;
@dynamic hasNftMetaData, nftMetaData;
@dynamic hasZoomDataLength, zoomDataLength;
@dynamic hasFileNameNoExt, fileNameNoExt;

typedef struct ResourceUpload__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  ResourceUpload_ResourceType resType;
  uint32_t zoomDataLength;
  NSString *extension;
  NSData *nftMetaData;
  NSString *fileNameNoExt;
} ResourceUpload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "extension",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpload_FieldNumber_Extension,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResourceUpload__storage_, extension),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpload_FieldNumber_DataLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResourceUpload__storage_, dataLength),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "resType",
        .dataTypeSpecific.enumDescFunc = ResourceUpload_ResourceType_EnumDescriptor,
        .number = ResourceUpload_FieldNumber_ResType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResourceUpload__storage_, resType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "nftMetaData",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpload_FieldNumber_NftMetaData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResourceUpload__storage_, nftMetaData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "zoomDataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpload_FieldNumber_ZoomDataLength,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResourceUpload__storage_, zoomDataLength),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileNameNoExt",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpload_FieldNumber_FileNameNoExt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ResourceUpload__storage_, fileNameNoExt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResourceUpload)
                                   messageName:@"ResourceUpload"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceUpload__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZoomRequest

@implementation ZoomRequest

@dynamic hasOffset, offset;
@dynamic hasDataLength, dataLength;

typedef struct ZoomRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t offset;
  uint32_t dataLength;
} ZoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = ZoomRequest_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZoomRequest__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = ZoomRequest_FieldNumber_DataLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZoomRequest__storage_, dataLength),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ZoomRequest)
                                   messageName:@"ZoomRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZoomRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResourceRequest

@implementation ResourceRequest

@dynamic hasOffset, offset;
@dynamic hasDataLength, dataLength;

typedef struct ResourceRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t offset;
  uint32_t dataLength;
} ResourceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceRequest_FieldNumber_Offset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResourceRequest__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceRequest_FieldNumber_DataLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResourceRequest__storage_, dataLength),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResourceRequest)
                                   messageName:@"ResourceRequest"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResourceAck

@implementation ResourceAck

@dynamic hasDataChunk, dataChunk;
@dynamic hasHash_p, hash_p;

typedef struct ResourceAck__storage_ {
  uint32_t _has_storage_[1];
  NSData *dataChunk;
  NSData *hash_p;
} ResourceAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceAck_FieldNumber_DataChunk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResourceAck__storage_, dataChunk),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceAck_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResourceAck__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResourceAck)
                                   messageName:@"ResourceAck"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResourceUpdate

@implementation ResourceUpdate

@dynamic hasFileName, fileName;
@dynamic hasDataLength, dataLength;
@dynamic hasInitialDataChunk, initialDataChunk;
@dynamic hasHash_p, hash_p;

typedef struct ResourceUpdate__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  NSString *fileName;
  NSData *initialDataChunk;
  NSData *hash_p;
} ResourceUpdate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileName",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpdate_FieldNumber_FileName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResourceUpdate__storage_, fileName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpdate_FieldNumber_DataLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResourceUpdate__storage_, dataLength),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "initialDataChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpdate_FieldNumber_InitialDataChunk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResourceUpdate__storage_, initialDataChunk),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.clazz = Nil,
        .number = ResourceUpdate_FieldNumber_Hash_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResourceUpdate__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ResourceUpdate)
                                   messageName:@"ResourceUpdate"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceUpdate__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NFTWriteInfo

@implementation NFTWriteInfo

@dynamic hasIndex, index;
@dynamic hasWidth, width;
@dynamic hasHeight, height;
@dynamic hasNameZh, nameZh;
@dynamic hasNameEn, nameEn;

typedef struct NFTWriteInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  uint32_t width;
  uint32_t height;
  NSString *nameZh;
  NSString *nameEn;
} NFTWriteInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteInfo_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NFTWriteInfo__storage_, index),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteInfo_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NFTWriteInfo__storage_, width),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteInfo_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NFTWriteInfo__storage_, height),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nameZh",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteInfo_FieldNumber_NameZh,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NFTWriteInfo__storage_, nameZh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nameEn",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteInfo_FieldNumber_NameEn,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NFTWriteInfo__storage_, nameEn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NFTWriteInfo)
                                   messageName:@"NFTWriteInfo"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NFTWriteInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NFTWriteData

@implementation NFTWriteData

@dynamic hasIndex, index;
@dynamic hasData_p, data_p;
@dynamic hasOffset, offset;

typedef struct NFTWriteData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  uint32_t offset;
  NSData *data_p;
} NFTWriteData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteData_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NFTWriteData__storage_, index),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteData_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NFTWriteData__storage_, data_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "offset",
        .dataTypeSpecific.clazz = Nil,
        .number = NFTWriteData_FieldNumber_Offset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NFTWriteData__storage_, offset),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(NFTWriteData)
                                   messageName:@"NFTWriteData"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NFTWriteData__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RebootToBootloader

@implementation RebootToBootloader


typedef struct RebootToBootloader__storage_ {
  uint32_t _has_storage_[1];
} RebootToBootloader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RebootToBootloader)
                                   messageName:@"RebootToBootloader"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RebootToBootloader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RebootToBoardloader

@implementation RebootToBoardloader


typedef struct RebootToBoardloader__storage_ {
  uint32_t _has_storage_[1];
} RebootToBoardloader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(RebootToBoardloader)
                                   messageName:@"RebootToBoardloader"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RebootToBoardloader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListResDir

@implementation ListResDir

@dynamic hasPath, path;

typedef struct ListResDir__storage_ {
  uint32_t _has_storage_[1];
  NSString *path;
} ListResDir__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "path",
        .dataTypeSpecific.clazz = Nil,
        .number = ListResDir_FieldNumber_Path,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListResDir__storage_, path),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ListResDir)
                                   messageName:@"ListResDir"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListResDir__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileInfoList

@implementation FileInfoList

@dynamic filesArray, filesArray_Count;

typedef struct FileInfoList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *filesArray;
} FileInfoList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "filesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(FileInfoList_FileInfo),
        .number = FileInfoList_FieldNumber_FilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FileInfoList__storage_, filesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(FileInfoList)
                                   messageName:@"FileInfoList"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileInfoList__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileInfoList_FileInfo

@implementation FileInfoList_FileInfo

@dynamic hasName, name;
@dynamic hasSize, size;

typedef struct FileInfoList_FileInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  uint64_t size;
} FileInfoList_FileInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = FileInfoList_FileInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileInfoList_FileInfo__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.clazz = Nil,
        .number = FileInfoList_FileInfo_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FileInfoList_FileInfo__storage_, size),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(FileInfoList_FileInfo)
                                   messageName:@"FileInfo"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileInfoList_FileInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(FileInfoList)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceEraseSector

@implementation DeviceEraseSector

@dynamic hasSector, sector;

typedef struct DeviceEraseSector__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sector;
} DeviceEraseSector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sector",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceEraseSector_FieldNumber_Sector,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceEraseSector__storage_, sector),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(DeviceEraseSector)
                                   messageName:@"DeviceEraseSector"
                               fileDescription:&MessagesManagementRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceEraseSector__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
