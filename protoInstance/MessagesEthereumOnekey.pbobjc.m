// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: messages-ethereum-onekey.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import "MessagesEthereumOnekey.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(EthereumAddressOneKey);
GPBObjCClassDeclaration(EthereumGetAddressOneKey);
GPBObjCClassDeclaration(EthereumGetPublicKeyOneKey);
GPBObjCClassDeclaration(EthereumMessageSignatureOneKey);
GPBObjCClassDeclaration(EthereumPublicKeyOneKey);
GPBObjCClassDeclaration(EthereumSignMessageEIP712);
GPBObjCClassDeclaration(EthereumSignMessageOneKey);
GPBObjCClassDeclaration(EthereumSignTxEIP1559OneKey);
GPBObjCClassDeclaration(EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey);
GPBObjCClassDeclaration(EthereumSignTxOneKey);
GPBObjCClassDeclaration(EthereumSignTypedHashOneKey);
GPBObjCClassDeclaration(EthereumTxAckOneKey);
GPBObjCClassDeclaration(EthereumTxRequestOneKey);
GPBObjCClassDeclaration(EthereumTypedDataSignatureOneKey);
GPBObjCClassDeclaration(EthereumVerifyMessageOneKey);
GPBObjCClassDeclaration(HDNodeType);

#pragma mark - MessagesEthereumOnekeyRoot

@implementation MessagesEthereumOnekeyRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription MessagesEthereumOnekeyRoot_FileDescription = {
  .package = "hw.trezor.messages.ethereum_onekey",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto2
};

#pragma mark - EthereumGetPublicKeyOneKey

@implementation EthereumGetPublicKeyOneKey

@dynamic addressNArray, addressNArray_Count;
@dynamic hasShowDisplay, showDisplay;
@dynamic hasChainId, chainId;

typedef struct EthereumGetPublicKeyOneKey__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  uint64_t chainId;
} EthereumGetPublicKeyOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetPublicKeyOneKey_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumGetPublicKeyOneKey__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "showDisplay",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetPublicKeyOneKey_FieldNumber_ShowDisplay,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetPublicKeyOneKey_FieldNumber_ChainId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumGetPublicKeyOneKey__storage_, chainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumGetPublicKeyOneKey)
                                   messageName:@"EthereumGetPublicKeyOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumGetPublicKeyOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumPublicKeyOneKey

@implementation EthereumPublicKeyOneKey

@dynamic hasNode, node;
@dynamic hasXpub, xpub;

typedef struct EthereumPublicKeyOneKey__storage_ {
  uint32_t _has_storage_[1];
  HDNodeType *node;
  NSString *xpub;
} EthereumPublicKeyOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.clazz = GPBObjCClass(HDNodeType),
        .number = EthereumPublicKeyOneKey_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumPublicKeyOneKey__storage_, node),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "xpub",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumPublicKeyOneKey_FieldNumber_Xpub,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumPublicKeyOneKey__storage_, xpub),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumPublicKeyOneKey)
                                   messageName:@"EthereumPublicKeyOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumPublicKeyOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumGetAddressOneKey

@implementation EthereumGetAddressOneKey

@dynamic addressNArray, addressNArray_Count;
@dynamic hasShowDisplay, showDisplay;
@dynamic hasChainId, chainId;

typedef struct EthereumGetAddressOneKey__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  uint64_t chainId;
} EthereumGetAddressOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetAddressOneKey_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumGetAddressOneKey__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "showDisplay",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetAddressOneKey_FieldNumber_ShowDisplay,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumGetAddressOneKey_FieldNumber_ChainId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumGetAddressOneKey__storage_, chainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumGetAddressOneKey)
                                   messageName:@"EthereumGetAddressOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumGetAddressOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumAddressOneKey

@implementation EthereumAddressOneKey

@dynamic hasOldAddress, oldAddress;
@dynamic hasAddress, address;

typedef struct EthereumAddressOneKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *oldAddress;
  NSString *address;
} EthereumAddressOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oldAddress",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumAddressOneKey_FieldNumber_OldAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumAddressOneKey__storage_, oldAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumAddressOneKey_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumAddressOneKey__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumAddressOneKey)
                                   messageName:@"EthereumAddressOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumAddressOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\203\247\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTxOneKey

@implementation EthereumSignTxOneKey

@dynamic addressNArray, addressNArray_Count;
@dynamic hasNonce, nonce;
@dynamic hasGasPrice, gasPrice;
@dynamic hasGasLimit, gasLimit;
@dynamic hasTo, to;
@dynamic hasValue, value;
@dynamic hasDataInitialChunk, dataInitialChunk;
@dynamic hasDataLength, dataLength;
@dynamic hasChainId, chainId;
@dynamic hasTxType, txType;

typedef struct EthereumSignTxOneKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  uint32_t txType;
  GPBUInt32Array *addressNArray;
  NSData *nonce;
  NSData *gasPrice;
  NSData *gasLimit;
  NSData *value;
  NSData *dataInitialChunk;
  NSString *to;
  uint64_t chainId;
} EthereumSignTxOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, nonce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "gasPrice",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_GasPrice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, gasPrice),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "gasLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_GasLimit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, gasLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataInitialChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_DataInitialChunk,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, dataInitialChunk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_DataLength,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, dataLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_ChainId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, chainId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txType",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_TxType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, txType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "to",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxOneKey_FieldNumber_To,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EthereumSignTxOneKey__storage_, to),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTxOneKey)
                                   messageName:@"EthereumSignTxOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTxOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTxEIP1559OneKey

@implementation EthereumSignTxEIP1559OneKey

@dynamic addressNArray, addressNArray_Count;
@dynamic hasNonce, nonce;
@dynamic hasMaxGasFee, maxGasFee;
@dynamic hasMaxPriorityFee, maxPriorityFee;
@dynamic hasGasLimit, gasLimit;
@dynamic hasTo, to;
@dynamic hasValue, value;
@dynamic hasDataInitialChunk, dataInitialChunk;
@dynamic hasDataLength, dataLength;
@dynamic hasChainId, chainId;
@dynamic accessListArray, accessListArray_Count;

typedef struct EthereumSignTxEIP1559OneKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  GPBUInt32Array *addressNArray;
  NSData *nonce;
  NSData *maxGasFee;
  NSData *maxPriorityFee;
  NSData *gasLimit;
  NSString *to;
  NSData *value;
  NSData *dataInitialChunk;
  NSMutableArray *accessListArray;
  uint64_t chainId;
} EthereumSignTxEIP1559OneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_Nonce,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, nonce),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxGasFee",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_MaxGasFee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, maxGasFee),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxPriorityFee",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_MaxPriorityFee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, maxPriorityFee),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "gasLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_GasLimit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, gasLimit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "to",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_To,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, to),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_Value,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, value),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataInitialChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_DataInitialChunk,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, dataInitialChunk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_DataLength,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, dataLength),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_ChainId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, chainId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "accessListArray",
        .dataTypeSpecific.clazz = GPBObjCClass(EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey),
        .number = EthereumSignTxEIP1559OneKey_FieldNumber_AccessListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey__storage_, accessListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTxEIP1559OneKey)
                                   messageName:@"EthereumSignTxEIP1559OneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTxEIP1559OneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey

@implementation EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey

@dynamic hasAddress, address;
@dynamic storageKeysArray, storageKeysArray_Count;

typedef struct EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSMutableArray *storageKeysArray;
} EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storageKeysArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey_FieldNumber_StorageKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey__storage_, storageKeysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey)
                                   messageName:@"EthereumAccessListOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTxEIP1559OneKey_EthereumAccessListOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(EthereumSignTxEIP1559OneKey)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumTxRequestOneKey

@implementation EthereumTxRequestOneKey

@dynamic hasDataLength, dataLength;
@dynamic hasSignatureV, signatureV;
@dynamic hasSignatureR, signatureR;
@dynamic hasSignatureS, signatureS;

typedef struct EthereumTxRequestOneKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataLength;
  uint32_t signatureV;
  NSData *signatureR;
  NSData *signatureS;
} EthereumTxRequestOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataLength",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequestOneKey_FieldNumber_DataLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumTxRequestOneKey__storage_, dataLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signatureV",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequestOneKey_FieldNumber_SignatureV,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumTxRequestOneKey__storage_, signatureV),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "signatureR",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequestOneKey_FieldNumber_SignatureR,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumTxRequestOneKey__storage_, signatureR),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signatureS",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxRequestOneKey_FieldNumber_SignatureS,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EthereumTxRequestOneKey__storage_, signatureS),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumTxRequestOneKey)
                                   messageName:@"EthereumTxRequestOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumTxRequestOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumTxAckOneKey

@implementation EthereumTxAckOneKey

@dynamic hasDataChunk, dataChunk;

typedef struct EthereumTxAckOneKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *dataChunk;
} EthereumTxAckOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataChunk",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTxAckOneKey_FieldNumber_DataChunk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumTxAckOneKey__storage_, dataChunk),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumTxAckOneKey)
                                   messageName:@"EthereumTxAckOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumTxAckOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignMessageOneKey

@implementation EthereumSignMessageOneKey

@dynamic addressNArray, addressNArray_Count;
@dynamic hasMessage, message;
@dynamic hasChainId, chainId;

typedef struct EthereumSignMessageOneKey__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  NSData *message;
  uint64_t chainId;
} EthereumSignMessageOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessageOneKey_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignMessageOneKey__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessageOneKey_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignMessageOneKey__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessageOneKey_FieldNumber_ChainId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignMessageOneKey__storage_, chainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignMessageOneKey)
                                   messageName:@"EthereumSignMessageOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignMessageOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumMessageSignatureOneKey

@implementation EthereumMessageSignatureOneKey

@dynamic hasSignature, signature;
@dynamic hasAddress, address;

typedef struct EthereumMessageSignatureOneKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSString *address;
} EthereumMessageSignatureOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumMessageSignatureOneKey_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumMessageSignatureOneKey__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumMessageSignatureOneKey_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumMessageSignatureOneKey__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumMessageSignatureOneKey)
                                   messageName:@"EthereumMessageSignatureOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumMessageSignatureOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumVerifyMessageOneKey

@implementation EthereumVerifyMessageOneKey

@dynamic hasSignature, signature;
@dynamic hasMessage, message;
@dynamic hasAddress, address;
@dynamic hasChainId, chainId;

typedef struct EthereumVerifyMessageOneKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSData *message;
  NSString *address;
  uint64_t chainId;
} EthereumVerifyMessageOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumVerifyMessageOneKey_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumVerifyMessageOneKey__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumVerifyMessageOneKey_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumVerifyMessageOneKey__storage_, message),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumVerifyMessageOneKey_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumVerifyMessageOneKey__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumVerifyMessageOneKey_FieldNumber_ChainId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EthereumVerifyMessageOneKey__storage_, chainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumVerifyMessageOneKey)
                                   messageName:@"EthereumVerifyMessageOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumVerifyMessageOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignTypedHashOneKey

@implementation EthereumSignTypedHashOneKey

@dynamic addressNArray, addressNArray_Count;
@dynamic hasDomainSeparatorHash, domainSeparatorHash;
@dynamic hasMessageHash, messageHash;
@dynamic hasChainId, chainId;

typedef struct EthereumSignTypedHashOneKey__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  NSData *domainSeparatorHash;
  NSData *messageHash;
  uint64_t chainId;
} EthereumSignTypedHashOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHashOneKey_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignTypedHashOneKey__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "domainSeparatorHash",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHashOneKey_FieldNumber_DomainSeparatorHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignTypedHashOneKey__storage_, domainSeparatorHash),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "messageHash",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHashOneKey_FieldNumber_MessageHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignTypedHashOneKey__storage_, messageHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chainId",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignTypedHashOneKey_FieldNumber_ChainId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EthereumSignTypedHashOneKey__storage_, chainId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignTypedHashOneKey)
                                   messageName:@"EthereumSignTypedHashOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignTypedHashOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumTypedDataSignatureOneKey

@implementation EthereumTypedDataSignatureOneKey

@dynamic hasSignature, signature;
@dynamic hasAddress, address;

typedef struct EthereumTypedDataSignatureOneKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSString *address;
} EthereumTypedDataSignatureOneKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTypedDataSignatureOneKey_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumTypedDataSignatureOneKey__storage_, signature),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumTypedDataSignatureOneKey_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumTypedDataSignatureOneKey__storage_, address),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumTypedDataSignatureOneKey)
                                   messageName:@"EthereumTypedDataSignatureOneKey"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumTypedDataSignatureOneKey__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EthereumSignMessageEIP712

@implementation EthereumSignMessageEIP712

@dynamic addressNArray, addressNArray_Count;
@dynamic hasDomainHash, domainHash;
@dynamic hasMessageHash, messageHash;

typedef struct EthereumSignMessageEIP712__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32Array *addressNArray;
  NSData *domainHash;
  NSData *messageHash;
} EthereumSignMessageEIP712__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressNArray",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessageEIP712_FieldNumber_AddressNArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EthereumSignMessageEIP712__storage_, addressNArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "domainHash",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessageEIP712_FieldNumber_DomainHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EthereumSignMessageEIP712__storage_, domainHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "messageHash",
        .dataTypeSpecific.clazz = Nil,
        .number = EthereumSignMessageEIP712_FieldNumber_MessageHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EthereumSignMessageEIP712__storage_, messageHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(EthereumSignMessageEIP712)
                                   messageName:@"EthereumSignMessageEIP712"
                               fileDescription:&MessagesEthereumOnekeyRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EthereumSignMessageEIP712__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
