// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: messages-common.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "MessagesCommon.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(BixinPinInputOnDevice);
GPBObjCClassDeclaration(ButtonAck);
GPBObjCClassDeclaration(ButtonRequest);
GPBObjCClassDeclaration(Deprecated_PassphraseStateAck);
GPBObjCClassDeclaration(Deprecated_PassphraseStateRequest);
GPBObjCClassDeclaration(Failure);
GPBObjCClassDeclaration(HDNodeType);
GPBObjCClassDeclaration(PassphraseAck);
GPBObjCClassDeclaration(PassphraseRequest);
GPBObjCClassDeclaration(PinMatrixAck);
GPBObjCClassDeclaration(PinMatrixRequest);
GPBObjCClassDeclaration(Success);

#pragma mark - MessagesCommonRoot

@implementation MessagesCommonRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription MessagesCommonRoot_FileDescription = {
  .package = "hw.trezor.messages.common",
  .prefix = NULL,
  .syntax = GPBFileSyntaxProto2
};

#pragma mark - Enum Failure_FailureType

GPBEnumDescriptor *Failure_FailureType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "FailureUnexpectedMessage\000FailureButtonEx"
        "pected\000FailureDataError\000FailureActionCan"
        "celled\000FailurePinExpected\000FailurePinCanc"
        "elled\000FailurePinInvalid\000FailureInvalidSi"
        "gnature\000FailureProcessError\000FailureNotEn"
        "oughFunds\000FailureNotInitialized\000FailureP"
        "inMismatch\000FailureWipeCodeMismatch\000Failu"
        "reInvalidSession\000FailureFirmwareError\000";
    static const int32_t values[] = {
        Failure_FailureType_FailureUnexpectedMessage,
        Failure_FailureType_FailureButtonExpected,
        Failure_FailureType_FailureDataError,
        Failure_FailureType_FailureActionCancelled,
        Failure_FailureType_FailurePinExpected,
        Failure_FailureType_FailurePinCancelled,
        Failure_FailureType_FailurePinInvalid,
        Failure_FailureType_FailureInvalidSignature,
        Failure_FailureType_FailureProcessError,
        Failure_FailureType_FailureNotEnoughFunds,
        Failure_FailureType_FailureNotInitialized,
        Failure_FailureType_FailurePinMismatch,
        Failure_FailureType_FailureWipeCodeMismatch,
        Failure_FailureType_FailureInvalidSession,
        Failure_FailureType_FailureFirmwareError,
    };
    static const char *extraTextFormatInfo = "\017\000\007\221\000\001\007\216\000\002\007\211\000\003\007\217\000\004\007\213\000\005\007\214\000\006\007\212\000\007\007\220\000\010\007\214\000\t\007\216\000\n\007\216\000\013\007\213\000\014\007\220\000\r\007\216\000\016\007\215\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Failure_FailureType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Failure_FailureType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Failure_FailureType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Failure_FailureType_FailureUnexpectedMessage:
    case Failure_FailureType_FailureButtonExpected:
    case Failure_FailureType_FailureDataError:
    case Failure_FailureType_FailureActionCancelled:
    case Failure_FailureType_FailurePinExpected:
    case Failure_FailureType_FailurePinCancelled:
    case Failure_FailureType_FailurePinInvalid:
    case Failure_FailureType_FailureInvalidSignature:
    case Failure_FailureType_FailureProcessError:
    case Failure_FailureType_FailureNotEnoughFunds:
    case Failure_FailureType_FailureNotInitialized:
    case Failure_FailureType_FailurePinMismatch:
    case Failure_FailureType_FailureWipeCodeMismatch:
    case Failure_FailureType_FailureInvalidSession:
    case Failure_FailureType_FailureFirmwareError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ButtonRequest_ButtonRequestType

GPBEnumDescriptor *ButtonRequest_ButtonRequestType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "ButtonRequestOther\000ButtonRequestFeeOverT"
        "hreshold\000ButtonRequestConfirmOutput\000Butt"
        "onRequestResetDevice\000ButtonRequestConfir"
        "mWord\000ButtonRequestWipeDevice\000ButtonRequ"
        "estProtectCall\000ButtonRequestSignTx\000Butto"
        "nRequestFirmwareCheck\000ButtonRequestAddre"
        "ss\000ButtonRequestPublicKey\000ButtonRequestM"
        "nemonicWordCount\000ButtonRequestMnemonicIn"
        "put\000DeprecatedButtonRequestPassphraseTyp"
        "e\000ButtonRequestUnknownDerivationPath\000But"
        "tonRequestRecoveryHomepage\000ButtonRequest"
        "Success\000ButtonRequestWarning\000ButtonReque"
        "stPassphraseEntry\000ButtonRequestPinEntry\000";
    static const int32_t values[] = {
        ButtonRequest_ButtonRequestType_ButtonRequestOther,
        ButtonRequest_ButtonRequestType_ButtonRequestFeeOverThreshold,
        ButtonRequest_ButtonRequestType_ButtonRequestConfirmOutput,
        ButtonRequest_ButtonRequestType_ButtonRequestResetDevice,
        ButtonRequest_ButtonRequestType_ButtonRequestConfirmWord,
        ButtonRequest_ButtonRequestType_ButtonRequestWipeDevice,
        ButtonRequest_ButtonRequestType_ButtonRequestProtectCall,
        ButtonRequest_ButtonRequestType_ButtonRequestSignTx,
        ButtonRequest_ButtonRequestType_ButtonRequestFirmwareCheck,
        ButtonRequest_ButtonRequestType_ButtonRequestAddress,
        ButtonRequest_ButtonRequestType_ButtonRequestPublicKey,
        ButtonRequest_ButtonRequestType_ButtonRequestMnemonicWordCount,
        ButtonRequest_ButtonRequestType_ButtonRequestMnemonicInput,
        ButtonRequest_ButtonRequestType_DeprecatedButtonRequestPassphraseType,
        ButtonRequest_ButtonRequestType_ButtonRequestUnknownDerivationPath,
        ButtonRequest_ButtonRequestType_ButtonRequestRecoveryHomepage,
        ButtonRequest_ButtonRequestType_ButtonRequestSuccess,
        ButtonRequest_ButtonRequestType_ButtonRequestWarning,
        ButtonRequest_ButtonRequestType_ButtonRequestPassphraseEntry,
        ButtonRequest_ButtonRequestType_ButtonRequestPinEntry,
    };
    static const char *extraTextFormatInfo = "\024\000\r\205\000\001\r\220\000\002\r\215\000\003\r\213\000\004\r\213\000\005\r\212\000\006\r\213\000\007\r\206\000\010\r\215\000\t\r\207\000\n\r\211\000\013\r\221\000\014\r\215\000\r\212\215\216\000\016\r\225\000\017\r\220\000\020\r\207\000\021\r\207\000\022\r\217\000\023\r\210\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ButtonRequest_ButtonRequestType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ButtonRequest_ButtonRequestType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ButtonRequest_ButtonRequestType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ButtonRequest_ButtonRequestType_ButtonRequestOther:
    case ButtonRequest_ButtonRequestType_ButtonRequestFeeOverThreshold:
    case ButtonRequest_ButtonRequestType_ButtonRequestConfirmOutput:
    case ButtonRequest_ButtonRequestType_ButtonRequestResetDevice:
    case ButtonRequest_ButtonRequestType_ButtonRequestConfirmWord:
    case ButtonRequest_ButtonRequestType_ButtonRequestWipeDevice:
    case ButtonRequest_ButtonRequestType_ButtonRequestProtectCall:
    case ButtonRequest_ButtonRequestType_ButtonRequestSignTx:
    case ButtonRequest_ButtonRequestType_ButtonRequestFirmwareCheck:
    case ButtonRequest_ButtonRequestType_ButtonRequestAddress:
    case ButtonRequest_ButtonRequestType_ButtonRequestPublicKey:
    case ButtonRequest_ButtonRequestType_ButtonRequestMnemonicWordCount:
    case ButtonRequest_ButtonRequestType_ButtonRequestMnemonicInput:
    case ButtonRequest_ButtonRequestType_DeprecatedButtonRequestPassphraseType:
    case ButtonRequest_ButtonRequestType_ButtonRequestUnknownDerivationPath:
    case ButtonRequest_ButtonRequestType_ButtonRequestRecoveryHomepage:
    case ButtonRequest_ButtonRequestType_ButtonRequestSuccess:
    case ButtonRequest_ButtonRequestType_ButtonRequestWarning:
    case ButtonRequest_ButtonRequestType_ButtonRequestPassphraseEntry:
    case ButtonRequest_ButtonRequestType_ButtonRequestPinEntry:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum PinMatrixRequest_PinMatrixRequestType

GPBEnumDescriptor *PinMatrixRequest_PinMatrixRequestType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "PinMatrixRequestTypeCurrent\000PinMatrixReq"
        "uestTypeNewFirst\000PinMatrixRequestTypeNew"
        "Second\000PinMatrixRequestTypeWipeCodeFirst"
        "\000PinMatrixRequestTypeWipeCodeSecond\000PinM"
        "atrixRequestTypeBackupFirst\000PinMatrixReq"
        "uestTypeBackupSecond\000";
    static const int32_t values[] = {
        PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeCurrent,
        PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeNewFirst,
        PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeNewSecond,
        PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeWipeCodeFirst,
        PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeWipeCodeSecond,
        PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeBackupFirst,
        PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeBackupSecond,
    };
    static const char *extraTextFormatInfo = "\007\000\024\207\000\001\024\210\000\002\024\211\000\003\024\215\000\004\024\216\000\005\024\213\000\006\024\214\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PinMatrixRequest_PinMatrixRequestType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PinMatrixRequest_PinMatrixRequestType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_IsClosed
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PinMatrixRequest_PinMatrixRequestType_IsValidValue(int32_t value__) {
  switch (value__) {
    case PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeCurrent:
    case PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeNewFirst:
    case PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeNewSecond:
    case PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeWipeCodeFirst:
    case PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeWipeCodeSecond:
    case PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeBackupFirst:
    case PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeBackupSecond:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Success

@implementation Success

@dynamic hasMessage, message;

typedef struct Success__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} Success__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = Success_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Success__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Success)
                                   messageName:@"Success"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Success__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Failure

@implementation Failure

@dynamic hasCode, code;
@dynamic hasMessage, message;

typedef struct Failure__storage_ {
  uint32_t _has_storage_[1];
  Failure_FailureType code;
  NSString *message;
} Failure__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = Failure_FailureType_FailureUnexpectedMessage,
        .core.name = "code",
        .core.dataTypeSpecific.enumDescFunc = Failure_FailureType_EnumDescriptor,
        .core.number = Failure_FieldNumber_Code,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(Failure__storage_, code),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "message",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = Failure_FieldNumber_Message,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(Failure__storage_, message),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Failure)
                                   messageName:@"Failure"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(Failure__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ButtonRequest

@implementation ButtonRequest

@dynamic hasCode, code;
@dynamic hasPages, pages;

typedef struct ButtonRequest__storage_ {
  uint32_t _has_storage_[1];
  ButtonRequest_ButtonRequestType code;
  uint32_t pages;
} ButtonRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ButtonRequest_ButtonRequestType_ButtonRequestOther,
        .core.name = "code",
        .core.dataTypeSpecific.enumDescFunc = ButtonRequest_ButtonRequestType_EnumDescriptor,
        .core.number = ButtonRequest_FieldNumber_Code,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ButtonRequest__storage_, code),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "pages",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = ButtonRequest_FieldNumber_Pages,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ButtonRequest__storage_, pages),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ButtonRequest)
                                   messageName:@"ButtonRequest"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ButtonRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ButtonAck

@implementation ButtonAck


typedef struct ButtonAck__storage_ {
  uint32_t _has_storage_[1];
} ButtonAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(ButtonAck)
                                   messageName:@"ButtonAck"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ButtonAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PinMatrixRequest

@implementation PinMatrixRequest

@dynamic hasType, type;

typedef struct PinMatrixRequest__storage_ {
  uint32_t _has_storage_[1];
  PinMatrixRequest_PinMatrixRequestType type;
} PinMatrixRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = PinMatrixRequest_PinMatrixRequestType_PinMatrixRequestTypeCurrent,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = PinMatrixRequest_PinMatrixRequestType_EnumDescriptor,
        .core.number = PinMatrixRequest_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(PinMatrixRequest__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClosedEnum),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PinMatrixRequest)
                                   messageName:@"PinMatrixRequest"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(PinMatrixRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PinMatrixAck

@implementation PinMatrixAck

@dynamic hasPin, pin;
@dynamic hasNewPin, newPin;

typedef struct PinMatrixAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *pin;
  NSString *newPin;
} PinMatrixAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pin",
        .dataTypeSpecific.clazz = Nil,
        .number = PinMatrixAck_FieldNumber_Pin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PinMatrixAck__storage_, pin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newPin",
        .dataTypeSpecific.clazz = Nil,
        .number = PinMatrixAck_FieldNumber_NewPin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PinMatrixAck__storage_, newPin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PinMatrixAck)
                                   messageName:@"PinMatrixAck"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PinMatrixAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PassphraseRequest

@implementation PassphraseRequest

@dynamic hasOnDevice, onDevice;

typedef struct PassphraseRequest__storage_ {
  uint32_t _has_storage_[1];
} PassphraseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onDevice",
        .dataTypeSpecific.clazz = Nil,
        .number = PassphraseRequest_FieldNumber_OnDevice,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PassphraseRequest)
                                   messageName:@"PassphraseRequest"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PassphraseRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\001\202\246\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PassphraseAck

@implementation PassphraseAck

@dynamic hasPassphrase, passphrase;
@dynamic hasState, state;
@dynamic hasOnDevice, onDevice;

typedef struct PassphraseAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *passphrase;
  NSData *state;
} PassphraseAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "passphrase",
        .dataTypeSpecific.clazz = Nil,
        .number = PassphraseAck_FieldNumber_Passphrase,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PassphraseAck__storage_, passphrase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.clazz = Nil,
        .number = PassphraseAck_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PassphraseAck__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "onDevice",
        .dataTypeSpecific.clazz = Nil,
        .number = PassphraseAck_FieldNumber_OnDevice,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(PassphraseAck)
                                   messageName:@"PassphraseAck"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PassphraseAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\002\205\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Deprecated_PassphraseStateRequest

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-implementations"

@implementation Deprecated_PassphraseStateRequest

@dynamic hasState, state;

typedef struct Deprecated_PassphraseStateRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *state;
} Deprecated_PassphraseStateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.clazz = Nil,
        .number = Deprecated_PassphraseStateRequest_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Deprecated_PassphraseStateRequest__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Deprecated_PassphraseStateRequest)
                                   messageName:@"Deprecated_PassphraseStateRequest"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Deprecated_PassphraseStateRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma clang diagnostic pop

#pragma mark - Deprecated_PassphraseStateAck

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-implementations"

@implementation Deprecated_PassphraseStateAck


typedef struct Deprecated_PassphraseStateAck__storage_ {
  uint32_t _has_storage_[1];
} Deprecated_PassphraseStateAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(Deprecated_PassphraseStateAck)
                                   messageName:@"Deprecated_PassphraseStateAck"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Deprecated_PassphraseStateAck__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma clang diagnostic pop

#pragma mark - HDNodeType

@implementation HDNodeType

@dynamic hasDepth, depth;
@dynamic hasFingerprint, fingerprint;
@dynamic hasChildNum, childNum;
@dynamic hasChainCode, chainCode;
@dynamic hasPrivateKey, privateKey;
@dynamic hasPublicKey, publicKey;

typedef struct HDNodeType__storage_ {
  uint32_t _has_storage_[1];
  uint32_t depth;
  uint32_t fingerprint;
  uint32_t childNum;
  NSData *chainCode;
  NSData *privateKey;
  NSData *publicKey;
} HDNodeType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "depth",
        .dataTypeSpecific.clazz = Nil,
        .number = HDNodeType_FieldNumber_Depth,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HDNodeType__storage_, depth),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fingerprint",
        .dataTypeSpecific.clazz = Nil,
        .number = HDNodeType_FieldNumber_Fingerprint,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HDNodeType__storage_, fingerprint),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "childNum",
        .dataTypeSpecific.clazz = Nil,
        .number = HDNodeType_FieldNumber_ChildNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HDNodeType__storage_, childNum),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chainCode",
        .dataTypeSpecific.clazz = Nil,
        .number = HDNodeType_FieldNumber_ChainCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HDNodeType__storage_, chainCode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "privateKey",
        .dataTypeSpecific.clazz = Nil,
        .number = HDNodeType_FieldNumber_PrivateKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HDNodeType__storage_, privateKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.clazz = Nil,
        .number = HDNodeType_FieldNumber_PublicKey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(HDNodeType__storage_, publicKey),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(HDNodeType)
                                   messageName:@"HDNodeType"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HDNodeType__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BixinPinInputOnDevice

@implementation BixinPinInputOnDevice


typedef struct BixinPinInputOnDevice__storage_ {
  uint32_t _has_storage_[1];
} BixinPinInputOnDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(BixinPinInputOnDevice)
                                   messageName:@"BixinPinInputOnDevice"
                               fileDescription:&MessagesCommonRoot_FileDescription
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(BixinPinInputOnDevice__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
